<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4704013f6af513d9c2c27ea7bf1516568ed03a3bdfecde192a72a90cf1e7cb57fb8cd141242cc307840aff1491789a7307a1aa25c546224eb35393e8387aefcf59c68e723aae1fe3da7d7ce1b1029b218885843bd81d39057ac960dd69d4942c8156151c30876c97a8a6510d1e8791ecba2cca895aec522fa6510552b70510811949dcea5855e2b111b4ce841fa7fbc4c7ecc4c5fa9d1283fdbfebb9576d4cad2dc543cf5ab99c84f63f90e820a5d740ab8534b5fd1448fad6b1486fb2ac93460c30e860b9cae53fac38b56b2be4cadd36a8aab982bf770e05ad4e8e7eabe814bfe6a756535c18521881befb1e34a150f5b1b2fa4a9738ae0ffe0a4da22365f8ccf02ffdb8006262c9e77e386d6b116b9f86da34fafc5364286914505b4f1cb803eda79028473e51c3737e021839c44279435a2110bd48e518ccc662831dff8e71da9fdbb4e1efeaf0885a403966510733320839d246fbcd27c5d05a980a2d38fa3590c17af2671eccaaf3461e140fee631ada10dc2bf7fc1cd4bbde91675f65d0564c355ac48c093823dd9663c928a0cb503a7f24988c42999678616a088f5bc6bdd197db054ccd0fbfdea76108b82149d444f5c7a37af10954cabb9d0efc6e9ee4d2052b60fead055cd8eb15e6f625d4b1a4e03c2f0e0e1779508412037507c657f86e1d06dba5fc3f335554e39cb6328aaa2999d132c7c90416b614a079f567c824e24aaa567d84aaa53888b5f84552c9cceb5564090cdbbe3e2e96005bb6a14e20f8584dd3106237988da0a47170bff8b9662f9591b5d8d5fa3e59f37a741f4d7eb661ed7e5020876c3887e097c5a9eec5c6519ecb1605d3c8795f9783762503024588c7e567a72c8bae8173f8f512a97bd95529903f6da96c35865e38656c13a4c246bedae10af8152e1b9e631ae4eaa4058aa83fa7c2e7bea660fc07687c9cb87d47e86aa5edf4ce620549036c6f3060d997e0f7d91630ec2ff30aa0b9ff6801068c86cd73e352a33e614c8d39a9a6277f6b86f4a224ef5721e9d9c24224c11ed512fe8638eb04f24f0748c49a3c74b5e94914fd0ddfb5537795ab0b6978cd740920a015f09306678ee65a23b6b361f3f2fd46dfd0a843eaa199c1bd38e77aca9b0258fc3b5026e334ebcd3f2b8b15297126dbacb04cee8162a833310fec1415cb0e83319891bfe50582a67af17d33fa31b558e15c0b816ef74e8ad268f6cc6a9054a21af1ea4fb6fb5e7b6d370b956b88856b2da357833403da3229e5da519c7b73b40f2c64060bd95b5662cd20e9b6ffe3f9b0d5ca489463220a3af54dec9abf5e88592908f166aed8fce2a05102d8f2a3f93acf62eeffafab1ac1abd79016089577a35515670b11b45a04cbbbc9579659aa1e95b1688a8f0ee67ae38e6ef030974ec3211c7480d929b952a909082e2fc814b503687d5d67747b142bf925fc618252d9fda6dd9345225c527b85d1fb1186eb9047dccdff1245ba092ffdfee0b003cdf825229f77da5ba32ad10352776e7f77c7bbfca4bb75d0b3f06d977129fa298b072b3cdb89839d995b3a73086c0b9e62c9e50fbf247d0131ba858f9324757b55e5ad7fd14ebdcd10b19869b21b22716dc9edf8feaca36a6da5589e7784e2b91f0e0d05e10e834d705effd107d25389e4b751f59e5a87ef4c42bf41adc98f8db350739a86ff3ffb49c583903cc42fa3be85090263af360bfca6b71b8412a35e49b1fd7bf3b4e6bded50d38be29596c36b2a3823ba55b5d76f031122cf564fb342b02b6d60e668c4f4d1b8b85fc8253a2d9d4e2c1fe6dac2f87ec539c0e76aff75f60a978f0bd35ddb36d54f79c10864a6eb4865b2f9d511175711f5f5d769bd783f41c5638e19cf357e376fe967469a2c352a2a079d1c170ddf2c49f3b9ffa9329685c3f77f2a5f214f42470e43e2524428f99706206f9907bcc7230030b322f15b686eaa9c5195bef5dee3039712665785e8a57d9d62f4d992bdd7d4565897fb9393ebb5873c4d4dcc734f707118b25d152c59f4e9a185794d31d5100fd978602e542bee0dfa0fcf8caa382be68b74abd44d3f5d968c0da2d2bf6a945a4bb3d5e9ede0f47ff46cbd92165cc46d7a3fff5809f9877af73f8d30077047aabc062d9bbc0e374e77dd1b4a1b836c61d9d2ab15ca908447e77ebd1908f6765cd869ce3210c5a3b65e5fc2529e3bdf76fa8ab9fcb9853870cfeea06af8ca22e289ccb20becebc35b429c3a3ba4c3d079879e352f496a33681d4fabd6f71dcdee31c92c83c7dabf8e275d061b62bf11dd0aa47a1c3e90339b64658c7453745930bc505a3ab6f93cd2e13506211b97251f027382ef5d72905e16cf187a32ac969467c698d40320b52da2f96637d1f608d4b7cbe3ab5761def3c838298c25482a367c526044189fb8894ec49a51b3c4ba50dcdd3a02791a0f468d3dd16401fec0eb144a6ba1ef3c0ea5bdf861f3b491dc854a678b8dbbbf451659ebeb3e9eed86aab8e40eec9d5356e645bba90342672f832b13db3d80a198c11a59bec5655327c8d01132e6ff891f6ae5815fdf29593f34cb12e3d2186c71a88d1444fa50de19683588499459b923b91316ee2962c8d1b5d4212449a421a359924ca66a116fd6cea8c5f177aeb6a62171b6f8bf333961dd721b0e95863d2128b55e8c9d5d97d69150aabd08f046b06a5a88e309a411ffcb9be2deaa929e4b6adfc771bcf88459986fbe8ea44d22a903cc9a515d0beb3466deea1c8a1ef8c09b0455acade1d2e6871415916a3050c9b2fc852fcb3f9e4e27dc27f7da4f6d40fe430f269c55f9279e13cbdbec8023b1f2d1e526d790bb477f67931d12c5b302159f86ef527bb2218983cb8bcddbe8352f2a217de0a28bdaadbda936b0db07c597a48a2335185e15b028a3f5323bdfc1d2c879b7f18c04a86fb9acc0de8c038cc459f9dadb4d4d691f394ea96050f0a5bfacc22fca662516add53f3d83eaf8a9d470db064bbfd8b9f8cf050503157c81e4c90390f5f17ec42d2f0c1c8c2dd88aa8c51038d8a1891a176c82757e3dd682bc9808f29d6602cb10f124d313d9647a782a2f13f31d4c1d1231657256563ce842fd94b11081ce56739310d611581da6d2fcba759badc3ca16b09fc58a3bb776e42b2ad8ad5c33befa1ba22284506a557b85166bb66d30172d0b193458997516edcb04352713e61e21dea9fce797937369b6b57421978d3621e756533e5700ffa11d410112a6164e335c2b29330cd93accb4c581fe08192b2a7681e6d9f062bec7d3e43de7fbad10bfd5956e0cff5e239985bfca85da6ee7e5186a90f6f04e04a9df6c56a65f7c8ce7a374cd50c1d0a11c845d6bd4139073cf3514b0fcd86d27c4a718a76417c1d684381636c7f9ddfe7ff87a31c49f0a3889ee481c28ff737a3f1439486b9ea3ff154d2cf26479317852b709647f4236d3f5837b580c77d6c1266e0e8c691e1eff7fe116121ead518078ea96deff99440c6e4824f2f11291f9c0ffc94ba53cf76ef49c60cbf50424ede366fe0e1cf84b584b85499e49088f51dfb1ce5ee21d26b33c5a41ac1698283579c1ded0181c456124f3d56ef48b77bc9cb7e01eea33227627458b90986f7025431341c262495749d9444af6449d5908aa4fbcbf7c656e0e82065e06743d3c78c9d1266a6c96ecd2c7b4b16d166523d405da7663aa87e1c1dc60a75193724944f37c63c873a8817920dc4294d78ea556d5f105426875a2a62187dcbee302ae9aadf1f9eb3a4b641b31e6daa644dd2e2bf22a55d47f2f8ee2f338b10c59f62e1e6d50c5ca518151933de75f63993802207b0a0eb9c8dbedfe410429a78a187ddad66bc746c92e534c296752f5ce46e313e11e33cfac92bce000518ad80ac88c7f41b34a7e560d0c69e6abba7a743353ad1a4e48411da2d42440c9d7ed2373b2efb3af8635941be14a827c34353a5f723193c948ad353cfd7a749f377a92fadde6b495cb31285f96da46b11cdbdd78c6adb5d0bb164f68316f9e6436020f54935acc48f56ecb71a5a38f58eb41ff0b2212f5ffe77693d715f72709888868faf4f7817bf48c67a350ebee869b4ebbe67d0bd1016477ca58a7673f3b9740464542635ad8a3f0ad9c9fe7693e28c3ee3b6efe9206f732d2418dcdb2a1ed6078bd5b474c4b7acef89090584e8c8b25b96603bc1bf98704aadb2a2e18552b65e51930fad19c9cd0cb769605c0dc82621ec1228f6a401d42a48e41e804c3738a38a1b71511be7e08057aaf3e4244fd918b2808b56bfff8f965ed354a235ed71465198302128ac5dc9f23af53eb3623989f0029f49cf816a25905c74fcf201d36b4bca495a613f22f6c3786b364473f73247a76920dce0b4d41888201cecce2077273e7597831a2f095114ddbd8a29a53db41d8184b90fac6092f8e52b65e595eea65ef8e57aeaef80969194a7b8b23f9d0232de2ba7c0cffde765e7074c9ecac43e82176e0fa3f687f6091bcad24447244ab673bb41936b6b2d5d6a58741ad4ca63db4c9f98f3f77b6d804b6449b76df78625ad051c0eb010f800491e2fc1c916628862ba181fd8eeb78822eba2d7554bbb43074de3853f84ffb4ac279439f968399e7f4346b2bbdd2eba700141d1f0886e5c45018179c96cdee29dc46a4ea0239e08684dfe04bd8f2a3edc6aa0a51d9e7d8908f91630ef697b69b385cf71bfa9c5a8ca03faf36f7408cee981cc1cae63cfa7cd550d243d75d68e11a51ca6db01355acf74f3f18be9f572252850f1b9d39e229c2562d888ce4c866cb8f4008d5488b7d0f2d14a0a6a27e7ec491aad00e4c5f1c74a44b465743de324529224bfb981ceb1b1808935addd50fa68d643a91d223c4f099439a62489263611cfb43693ff6c4c3bae540a14de6638dbcbd698628505852865d5d52f4f1fe2da32e768a3479a37b3f519e3e7331ae4f7827043e57cc3d7676cf7b7fac17a7bd4176e78d27de05b9f5b806667c35c09b2287f3581fb6fae7dca35f06ede3faf42f94c45529f0d645c59660142aca81815b5ea2b0ac33ab9fa521a01fe315306fffb9ec045eff71b2e17c8102ff6de5256a7419e6c3bed919e7f6d9f100348cd10375fbc7c456d772607a66162932f21ffbf7dbc5a97b5cff6692625a5a618be668a78c637fbfdd20578cd277c42d46d54b92db2f70d2e2d4f596c902397e957195dd4ff0eb0fa32e832e6618d1e310db92f16ee694fe50a6b528dddb4c44e08a56e067a0c702830a474b7d5524ce8d8b6431f3e5b34d22c84b1d03573a2bc2a5067f4c617a10f310c433cb9968e4dca4a0d75e80b53ba4f098a35f0db9f4f13d7ffa9db365cb900ce8bcc5152edb07dda1be602ef9875671f23cf8771d2d17b0a61b318af03cb53e3d40fd28476b5665945e3b9b724134a72027f54192432ac323f0f9403c11a12783e6f93cb6da6fccba6030f88c5934c49e81804adcd73d7d8306334eb5fea9d6c44858790b63566e22386ad4b187ef21ab865f1ef3322313dbbc87c4664d53f75cdffe159c671ab047307f7dde84ea3a3c8ee84a73bdca495eb43327be9bd8405c3cb0807f7663ce3564d0c4f4b418904cd9b077cd182bcd40a18ae1adc8662d8b3b93e2f0a0b84cbdfba94e90b08abce571a7b6499b93b338be921d3f7acaa7c81a16b9b9b242a5373ba51518649b1ac12eda17f994c61eaa5d377589aeee1f8bc85c905f1f09e28bad4c2c5682395759b4d7b2864d4092308934a584224ea2c6330c7d6a1e8b03af6b8fd7e7c06f35db659634ae68e25b3e59350ef1c23bd469d39166657c126362d113901012e3f4f3e101b96930d38d620a46302d166fc2ec001f4dfb42534966535aa78001c1d05ea0e980bc1cfc7798ef3df200cffa92c9f00040b7c31a5d8e179d43686a0843ca7f2ed6051d58f5126905afd3ec6f25bb3a7b1f321904b956c17184111b715855eb41cf509d101859015765091fa56cb04ade2694d059bd3df5a71d1feebfffe471903367cfef58e54992a30f1607b94067bf5ae4b970b99ce3ce56fdfde1867291b163be95609f1a4466e321d88271ad880c4dd8ad4759c1db4bb23967e86628084a0d99fdeb24b1b0d028157bc524ff00887e7e5184eeec995c7658fb7702a2246e553e744db864f3836c68f73915900af98046f5d1ac921e8624f211f4138d1b2ec2a40cf830f25f094f70e455852a67235acc76b449c6f9abd87e7b712a5f0f20b44c932b25709db91495b96d2efbec129cf88ae41746b98f90739446e24474bcdaf4c2207642c5897b2171de0e88e593b4ba2bf594d7e19eeaf11f3ae81308e95bcceab0538afd0a964ed7cc4655aa7d46beeba2d19f1976818b2348d4d0a8c8c59f575d8ccd53a7ef58647349b6a75195f9529a13d990d1e30ebf3919e7a26d519b6e9c9678785287fb35771b2c7f97271dbc079720b79dd1edf55e711f09833c7f6c7e66936a1559c42db949f4da6ec170947917be730975998abbe5199e54d8d3f48679c34e770c6d62f741ae3231f85dac8aed7a92fb573c1f70628a7d355a2dd0de7b51f81a456f5d88d8a4369c3ef36602aaf64cac9d95056f7b01e23c8eab6c679763a16257e7b03fdfc5f16fe55cdf014687706792ce72414ea325757382c71a440578bbeca64eb00fc40c3e81948fd6aaa1df1cf91cc339e4e71bffad313619605aca846c702df74180b2296687347d4857b28059f2d13b9be0a1672ffa8f4368d71472fa513418dcaa3686f67bc93e13a37f93580c1570b6298abab77a32b4d5c0f39269636accaa76da627590796e79e21c9396237cb19cefa445243f4012562eecc92751dc062c4c5fa2eb05dfce2ccc2f2a644edde4abc0fee95b04345fa44aa22beb7697d10db4a00fa379748460ce04135e71e664c9b3d8d65e184b1c01d38189c0fdf19da3ea65bdd391b5d4c88ea47844ba4a39ebd4e7fcae5e91f2d456ea1e79dc3828dcc985548dc92be404d7ba82b7930a196fe6df49adfcb354b919a7f1c496e57251e17cfaec5a928497f06e358c82ae6cf794020db5cffb6b7218eed9434f2ebed72a2b9a5b8050280feda088b1457ae5f7c366b9445650b96383e04d68cb7311425e95c9414cd6147cd16ef470bba4ad6ec09fa7c7ecb720463bf53613f072fb5732e11ed2972bfd0a754a084e0945b45f6297537293d9c949f4b34ceeadb8c913ef7157cd99ca24900a450f819d65277716026f5cd84f425f93aa6b65aa8b8dd7433c93155c894365ee5e4c5ec542f89120b756f2d86ff34e0600801121c11ab11a969aec118c46c546a2fb81ef4a54994fe8ea8d64c8976a3ae01474d608cbc8536441bc6cefd298dfcdf0fe53d1d98a8e1ee44fb49526421e3f04ab7b3f69bea1dfff5f050d562f80c2ec6580d3731b35510e96331029f98d4018fd588e5325d486ec3018e04463ecf6694e05a7a58d900ad774ce413db037ce797d5206c8e7f4038f4dd9bb4c3405898ee58821e93f7ed1db2a90c79942ee28e92c520afe7af2a22eede36b0b5ba4dde81e36b1fc98ddd3d106a71f495cd0aa83b3f5729238c3bd96fc5ec34c8d5f915922705b1843182ef1af293b548e80a21f9af9467d6fac141396ee4f1bdc9922ec24461e111f97c5d628218b291816d3d3b08d4595333fb53e7b7f4d95febff650eb681b5825b1e2ce54e79a049389f269d512bfbb18a00706bb4da0601d5f57a3f10a25c4dbd67d9fb5ebc475fe9f4c9d8938b5030da99c0bc00fbf1693c4cc438ca804518a0cc8c03fa47cda33a1958fd886d6b8080bee4801b94e371d4ad9d649f8936ab62590c28cb25896f4aea54f5b6dfb5d6557746406ff996b8c6b6ad431956f070088887745593cb055fdf0ee038dd63feb6fd4b88a1ea84387d10255b1480c1e8ed142a486422cd4e3ed3cd49e8d40c8f64327d32f0ac80322e72aed46790614d26464693fa7dacf5f4f8182834cc8ead3f7e26de194300fc01690884fe851540ad9715d59ff624d1d0d7a5805a954481eeb80649bd2a0cf69be8fe6207cbed84ddb66b51bdbe37e3d0d55673ad7c4c2a6abfa8021a4a695c53aa5babdb990d7ca0eac43d8579534fe4b34a947959d6c6aa965906a5316d898e1e2f26c0cd7674579ebff571a394b6b3843a76689a01c4b9d2f6a3401b404b6edb3b782ba815bb22e8fdca74034257c0f5d1f97e5a2a256f65e7c91c22df1e2d6b98ca3c08d7068f1140332eab6fb8fa40d1585b071721d08e1a92ecc50842f19bd05ef8fde2f82807ce1691d5db1cbec182c45e2b4b41af63967237654d6d160d2d0efffcf40e3b52c4165d110f2e5c9fb683e86deed347bc5519c66f25f5579a821ea6beb3d350fdaa1e32dd80a21369e999a207d1cf9099ae7a1b9bc423a9874d4b2416e5ccf5997a5ec3c0ecb3b960e927273475e1200c16d4a490818d0f3da46aa5fe52ee8f370e1923ce55ae98d5b27fc0593e63762d19a1860825195d48c091a88601d630e8fc3c0dfe28e476f71923eade5bf090d8fa5ad49cdca4add0950a692422f0f484e0b0e202dc008affc15e74f6ddc37310372768f982d08e963723238dd5ec3f67cd0ade5146ab52703ff56c063163f03ae9c2e0c9d9dd44f19436279ba047e71a8e8093b24cb74bbb49f988311afef2b69565f626d63edcabbd9166c7c0cb014bc759904dda2f5c705398cd188f9a006be777ac71f03a28644fa4db407f11a848ee8e28a7e041936194ec4e5a535287c334193a17dcf8a07e989daf7a41997ac054a641807abd79cf6319a9ee709c57f6f8dc29abc8d664b76de202f1cec26289d4b19bc7255bb739065482b311938154d9e5f9cea12b6cdec19f0a52dcc6bdf89494c5bc577fc7c607b58abdb19a5d45f74f45095fbd004789c17bea1dc98ebca776633f5ac7c6f4e9b281e0a848bf46921d26200de174a2c29133d47283762603c3f606ecca564fd0943ecc095ecc5cb6773b1f54ba6d30e179ccd277e648d21abb8918dd1d32e131c44ccd75ec9549eab42153abdef6dbd0d810c84e3244a78f61d7f22e99e76f75862e5bbcdd27877309f170d87831ce5593906412929adbf9a20f3dbd6b5d222b45e5f6d84c11a9aff51fbd4eb808f918a98737d79f5631540f7aec140afcf123db0e8ed20334964699cbb1896458a9b237f320ca38a7e1da9d1391a5f33e6b9ea594d5aa5f3174680f0f28aa692a3eae6fa134b69132a90012399ae05b68baac9bb3c69b2f2667b38a278cf2c2fd09e8b13a4b62f33f39dcd040187a1e3eb87bec617d2a40cf79d3cb0b1b676e9a545927db6493124dd7d35eadbc87dffb02b6a7fe7fe175c7728e19a406580d9d215e7d560370ace83446a743667f7232f95a3a07fff376d639255625df51b9c0523e3bcfe5cc0c7edb93e4ef79bd744f8a899d9b8fa55a78a55f6d890de87e1f0228f6e2ac6ea154c8f68a871c4b16c1c1b42a9f9a327b99572f25fa17483400e97d39876ee09434257a9bc5d1f3ae42a4443b82edf39d194cfdf6e68f1d300a5ceb4b3cf795b85b599eb27de40661c63e3a76c717001ed25937c2b6ad5f6f74c9f06936786f9661fb33ec15238c4d81a6b321cd32cd53fc375259a2318fc01e76bbac6f99be5ab07e5f03aa66b3e041e5f9b5715400cde182868021cb50fcac2b7269ed08609d4d4fcbe91bc3bec1c0a9d4f74687d73448c7c6325584a076ae90f301a6acd45c4e293578b6c83c536d0075ba7ec93d6b097641dd035a74205cbe82a58369fc4c3a106770621b3d3bc4954675d08ddb666811c0c4f5956806bcd023c214e12694094a1316f446e6480e0e123efb98da2276731a9a5beb7bdd330f5f32880c04c9b3cffa5abddfb75428f39ee79410fc2f9488fa925611d776e4c8e4a63a19038754f7e0fcbf2a4d0c80eccc27893cfcfcd73a656d1a65925ec82b8d4cec9789914b453cf4ec5cccb0f87b9444cbf737e7ddf78bc4b460379b3fd86d2408012e70756bd1c093dd1ba12ba45af8b0e8c883a9977f757b40b9dc5aebf1a14fe0c95d97c5824b313feb716de48979bc043b6e3a9217008a5d26677b73ff09935618cac8ce45c961dbd575c672fd8efc54404d5fa7e648f66bc9e54aa0e640b3c4e1fc3bcc7a0ee4f76c0b693018538d5bcf73fefb9ab56ee2bc944e7fdb223b1b914ed51774a3c0f4202605057c056ebb1f123f0cce4a796e3f0f4140c2e2db02281dbafee27788a0145498a3ed56045c8a219c2d5dc5fa3aed98291d4ca732eb74db0afbbb8a27e6f69aba6d609acc8f363c13d7b004da4d3cec272a35f1803ee213754090e4e8954013702b2311fdbd52e9e94323552b931c714739ce5413e587e27a5bdf6266f6b228a2e454e0bda940a59de5a2967a278b550a9f15bf31ae94ee817c7c0759325d98b928981dbba027671425a2f2dab26dc08feb7aaa173b78925af1606c25d7e9416d485c1e943d6cd57b9e1ae592d36d6511fa406d21d7da41061885b05b5b13f5cb3ac9413ba58a3d188d8799b7da93cac8b4abf6abd5f24faecb455e851b00796f8ad4a3126a65d11108922d6cf3bf990040bf99ca2ac1652b23e8a8c7b8479d759d9574e498f6b8c57d029b281899ac6f0b0a3a3779194b6eff8fe09ef69493b73fdd55c3658f2ad0b2142244263cb2b33947226c0a55167cf676dbad53e8c8377850fb1edcb508d5d0445e73e6484292b80d63bcc7215ee0cbfa603b642bfbd731e7db6249dca6301c0abb26525385712b6eecf78e2149112dc3978f8d83596a9ad0a873f9afcbdb352429307479075d22fceeaae3954a5176ac8186b3704b7903c8b6386f976b346608818b39e734ed81debb30018ec5abccc1fd865a1c325a520ac3fa1efad2d7e0eebd6bcff7397bfcd8e2e97adadb5ccb657d5530096f12ecde55aab11d97333ac2c549acf95201ac33c08e9668375ed0c71a195b0ca99565862cb8979f66a9f0ebabb8c8536e938bac064347af3e503d0acfbd4a8baeaa14d16cde560fc118b29670b1ef9ffdcf7c8df689b2d0da80f7fe30aa710170e09557856a1bda1b7d12ea9a09631ef8cdb0211216ca90bc8e7a887e8e581869920c145274f978fbcf3da6ffeeabe5217a277080b231d8eb6643bad94d2704861d8b2bf455a4415f46103c24e7d9b627be30a88049a15890bf251ec9d62ef16c17289453e56cd473234f63242df2aafc3290ffe8327325cdf37f7a15802beb6f35dff93d4c8cbdeffa14c060e85e5b586cb115148a3826b02306d3433c0a86d14ae1acd7ea48f9b87c164fdb13a889c21a4b483af5f567b45011a55570b61e56c530e883a4861f950b0a93515df7404284057ac91fd8378fbc9195bc2e873e5d4b850c026c1871f54b4ac5a223ea5f6c5510530d9fba5f6f54481bbebc73dedfda101ac314dffb3569a46d886d566f35fceaf30605077f3f624d4175fdf894120324869fec4b04be98867383666c34bc6f25c34282f736d2e7865fcc12cff0edbdb5e01c25d23eabbd8e22df620a585ffe9612cc2b3e51eb14bbf2137aea259dfacea37731eb986053c4eb8f5c3d6dd03d7fbc897f0b316eb32acc1927ca0bde0c44fc46d8c2c856367b8608fa2a7c033a0b17ff3bc6e1aff792c2eb0b25dfc574052f51be16d3e8e0b685a2c427b4b56b4da6a872e197b5b2ac63d3af03dcf990ca99969d98a95472eab794226cde6d0ba82e27b0b4ba77f25eaf62d7b3b2a9af453b35c5c7c30d7d1d865f9b1d158c73c12b078dd518096884ba83b0bdd8f1a972e6d1638bc7e1950043a7639c1ca7fcf63cd812ccdbec69e6f33655ba6d0b61a6a6cfb17b1e08636375298f8b66d746c21035a584b3574ac03b263a177fac7669d5b99b65d1065d375f01d668de22deb75b1453b48c72ac57cbfb0c0d397d8aeedc8b26eef645dc75fd78b8246f2a86d9828fb7366df73f6ca4d4087adbd9589168071ce9a76bc9a25df777116dc5dd046004ecbb8345b05bb209ccdb000270f8469ee8d2641346633e90eab93c3d1a3b7b1af585ad616638709847983feae61ceff5830df1ff91b1461d205e6465f064579fbfff47aa99156bbdd438ce6436ee2074d61e440b76be9ff409acb2b6c0cc40edc78c57035fbc0959f471b5c0e5bc09ba121ce33060b700f4addbaf2b6baacb03ca779b0a9bd6e74e0b8cfceaf77c817805d10c285702dc7d584d90cd2c7a6f5a8503cebe16618dc9950fdc8cd81dc922f38f704e5a15295b96026696f807ebc3a084c10ddfc23eae086898c781a1b02b820e85fe3c8a0cecf534f560bf3c17d6923d6c552b23e1e80f41b2c335c4bd8702f56e2aa4eebdd232107eb2dcdf01d067a57a4ebee7580d04fa8bd9b81fa1f8916f84a32da75022d4e25daf9f271d8679b118bf5a342d97606bbdd5f1d9be6c0f4c759efc6207c3c4e981ffba6a897cea9c3f0e441075666a59d902472e2e10da1ace0fcd9e072a1643d0bb3f47987017dd53f1c71bce1f0091e855535e5b4751f3809db1a0c5d2176f983936c4924a9f1eec08eb4f21b19bd011160f54ab78c913e43dd43c9fbd88b736504287fa1d2804c20b5f62f71a48367deb3f5ea4c16393a72a52d07b6d781ae6de09ed93415082b0ee1f9383d1c224db4afa83bac3fb9fc0d0543db2017b4aa8a569b9a9177267b66f051ce1ad4adcf4da3b1105422745b44f49d81642fca716e7ae10824ba342ba59ac53c169e910b5d51c9cc192f471de2c4e927cfe06e3b52edc1c7bbfd3fb881b7f285ba595a37c03e7208c96330676dac7f15cae59642d3c2c1d1ae3614c87146f048608c2bca49818cacef8f12c61997f8272979e3eb541f4bf0e8341560a44de3b9566b1712e7f8ef68cb0d29428a0c70ea80e2d88ec86ad138026ffa4f2fa7bcfb14330df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c8468bfdae736e04c92ec57ec57c68df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
