<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a34098a91d1aee451ae8240282ca121cebea9d787dc5437c91459c2fcc7b0001811a12261b091625088585d845bc263126ea44359f3c3146cfc44595ca87436ffcf83ab59f80ae13a52f1e9cec3c54c1817714119afcfa85681be319020c7829ed981a73cc7e0d38f90c2e18853a16ee718f88213094a2ce50da0fbf13dfed1a378ea6d860fcb92b88642d1eed26135f792f5add897f378f40fc13783c7b199a0bd5a2642777b94649b4a6df386352103e76f0fc08f238f84eae30a0550ae0fda37b5dc27c59803e99a9ed53b29898264e4ac72f297e2ca6d4ff1800db9c576e02fddde1fc500c1b2f5792d54e106a5126a99682917a3efa90b80fb77966e2b08ee2595ebd1af9796758e7896818270a08ad3d9e6b57ab4ee950460a0c081fdda1ade5e1fc647485a7aed5f82e8eee462a5b8d6e222bb3f3095cae593784e8e4c7d7ce62be2e33241bb48df1a062157ce6d39b66addb1171d7f0cea386c8cdb83f5fb50c8e85512858e594b749b6e90cfab40026f8bea3489e06f11dc8fcbb8d7fc79241c2b315d3e427d1b51fdf061653a9cb6868711624c8d17b3ab82226f04df28a72b0600b29d1b570acb6903e0947828ea37f552b7290759448bb228cc6a54cba6e57130beb00ef308dbc171c6379a1e9cdd5aba98a558e046a600e5ecc9e1e80217d7ac0b08a30b68ce6a8955a8120a12b64a24c7848538311bfe8ed443b6cc4f441e5a46dd0f773c214b5a262b19d6d8dfaa43b6b052bd180d27ac5282fea2fd0bd0fe9903aa2a2f6bf9de019622f19dd571bfb872c15554f5f97bd37db4d6210a2e92296cc4df78b396addf999e02686ed2b038422d3e54afdaaddedd2b55ead700a9cc177fefc91f4150219dd5ea5c17efad8d1ac25bebc0a3e15597ddd6067d93fecace4b255d2ac0e353acf949fdbfd3ad6e6675c6537089356b80d5caf96c1aa2e37ecc1870c46c984150bc526235f07444d2485e8414a0f67d918562f4aeaf308f5b78c3466ebe31793f274de9d9a70817fadd8012117c34daf2a57f6eb340c91c3e2cb4cf91ab1ac48811e27b7b6cc474b686963c61c54c48778f2430bf94f35e951f00b85d341d014b820a05f69268eb9bdc9fb8b622ddf66a59470b81942663dabbaec2752fefe3924f07bc836c4eac6f13deebd7d30602b6c7a6def69bfa16c81f4ee3508e5bfd28f87cc4bb7bce2a0224425c633db50dffff9ab6360fae160c8986b51c9b7c56330afb074bdfa7f9de2dcaea7990b66c1ef7da471d820b1505d4aa6d94f1c34a556f6ccef4fa537014b923dc9f9abaaf3153333a7b29a231c8646fa697253caeab5ab6c55538c2d6c8acd5cb9ecf414918ba3a09033404cf83f6faa3ed38e34c8e2d12c33a3d361c17918606d7f1b59fbb0b743628f9da7a555b63c9a88ba113d3623162c372accc86aebb7c5ccacdc844695f400157cac28521dee24fca2741b391ae75e8df6886bdf6cab19243a18d8621d7a8aedb56bc043f324a9263015fb93f82b897bf69818eee8da13d1f14fa5220d6a207db5927ba7b742d03be94bb871c8c692fd210c8dfbb62a2dcc0da6b7c70114f053c2cdbaa708cb0986a0991e65b2ffc8fd78c0f7cb722e1fef684104086a9b869501d9da82d13b8f1979668a45ef36ad4f702baf8e3b8b4b5a4c6fcc56d6e2d01a9770e62f0ee7d249b690ce827e69ecf0a659a1ddb7b9ac66f4fd0772e9abff9ba3a4c223e11871c450cf9cad2d4b7cc3e10424299730c0769894f189b2f7a8dc75c10c7584ca75c6096f09919f69ef2255d291e5fb60c76ac8f909729d5843aa0b5f020d0b2ac72618b9990b6930460b550ce528f8d7b945d636b940c7bf7e4782a68af851eb3529e71821bd5c78948e70f0cc731d84256b478032aaa1729d014bb39e71619a2c1252d5d35008581d1df1265262e73af9a5f196494d6ab2eef27abb91c436da9414104eeafd7e44415ebfe5fafbc2174d9d240c61956c2c8068bf20bfc21dbbf9ef25b9f9dbd7120f6b292a1a861a511ea28e59cd6901c0f06f5c58ad22891f8761d49c9e14b963f8e0e8c3baa3b8da7bb6229a919726d59a99c4d52caa481fa65b469aefa172aae727a74b3de06485ea94c7e7f940fa070ec3013ab3abebc62e4e7a9fe1899d47a28909f72cb665444491b70ff8a9f1df4a8447d029a9c2dfdc249ffdcf2ecea7c10a9a27bb7b69b4e6a08cfa00ddcb0dcf5e8408d6e57d967f250ca2d72d3691d7f74fae6a14bbba9559a3503ec08eaec0d2b99aca698c3ad797c0e235f877cb106428007213e299152902e8b34f342955850bf85e3c156d564bb81874c7f0ec55fbbf8b890b2d27ad8a1abddcc2741a67b2aedcd623d43bfaa1843bc878c11fe258c1fb2cdaac2d2f1b1a7330313c1acf77f55d296f6689201ea4515313024e7b2889f87d0129656731fb9239e94f852875ad7c9a5ba88d473c26f32a28a073bb98948fd5bd9992c2c30631fe001dfa28e5ef7ac6db0f2b2f629d2cb584d92955c910651b33251bc5d06502c3eebac661be1ca56f0a2ae7683259d4f2101be37a620886c7648ea83c390ae6d7c88755071641c4a4a869c78cf477dea59cecb720cf527ebc8f1c1d5856a6ef3d2e62944bbbdd039f6cde6d40f0ac59fc33b635fc65a9bd23ca93812e26ddd61d0df6f41143150753f5c33d745725ce94d0bc85c4fd7f0348bf12988e5fad72ffe77051a1896c361ac27d91d93abee3fdb843448357fd0c2e4c1b166ac1c14715bdd9155e44d5646d61b860f41c0621720eda277fef8535a3fcf78729b36062fb8f89ec18574a8ee1d86cda9f8c756c65b635edd8614cff98882fd9a8aeb7adba9931b1288a42a8b69a22cd1380c2d23a66dd5cb7e85a9f7fbeb2ef2494efce6b8dfe740b07b3906e0ae3962bc58fb66cb3cdce1fb20ae4e1822cc65459132507473580a1a6225b23aa81de823d2936957a187eec8cbce21d774d01a78865fa2f424fcfc4da11a0615d85739d7784fc91c5ae3635398bb8a18d0c807507f3a5810806838dca8476ac71a0676492384c4ca6cee7ba86bbfaf8c19f97530df06c61e74aa96007ff41a8600a8346242e78d02962baef480e4d01e831990ee98e8c35daf7b20b621986eabae75bd96989290dcdd9230f7315cf61893d9f1e4b9f0c794acc5c0bda4ca12446df7dff90e3d52c7ecc007aea18a3503c629df663377b5e66895c3cb312a4963295ddc56c65a9957aaa378375db5b790ae2ed325915f465336f5e5ad33290d65dd783c9be6faadcfc2cdf13cac03ef9cf270ca0badcd3e668c15bcbe89aabe60816ae8313f1ca59ec951485819de1a97bbc31684e16ee41be210df52f8513865668ab4458adeeca03515e9ac39702d05d68abeef1dd3779a8c0a4971a33dcab2e58b945c47296b21dc2dfe3bd93865d3edcdfe9e56eefdf09f3f3a1854846ae3d945b5b38e827b3f10ab0f831f2c0153cc3af4a13b67ba3a7045735197d031c668f937b37f56b436f2ee4b08b7e0b8aee593bb8803bd14d6b1de5ac21f470510890381b65e21f0ba1ecf7af19e8674b5c166559fdf13d8d4e1ea43b5ea026f7b9ae9ed46487ca423b8e60956fde4ed78cd83af6df3e9a7fa64149145a723012e99327f4ad9e4a7a26e6aadb6eebb83de7eec91072f11d64ff534cd9b4cb7c7bc32e3beba31a78ec3a16b2955688b743418d50234aa8f9bdbf977db43e44fc294ccbcd65ec2af0144c6d1d2e720c289ccccdfcf04516407edccd34362aac26e0b0ce1124bc93f973a38ea8850dffd960ab892eebe82f869d6d660f8b8eddccba7141b440f04d20662a6b2a28a41caecb80f4989be308689bc759dbc9d07558410c521ee0ee46814a518ab0b40c1ee947b6a6272fa4b6c7fd5d58dc3065fb442bfc7d7489ae88eaa3369f69cf749b30e0fa37d65d85729cb2634c353d081d5fe127744b21ce1b35c89e51c87c9bd52f3f3aecba9cdf74752cc492ef673bf91d0793c50318553a71098111dc5c40ff2929ae4bd958a5d3a09bd158aa40a414839bee95d6d287c4407a13c18e2b1c1ff8f1686aeca0f92040b3a8e395a60e67a92073157f3fe37b34a14b75a46dfa80cc71fb7a3db8925fadfd222e4bd734ada246cbd16c93a7fda7776ad56916454a26903a81ea1ca35c21c6a0b41406aea0f57d28221a07c1af1b06334db3a55e6d00a1522422bb83985f600a3aefe01feac76c1ac88c29f9409c9ef4ee697323faf626ee73cb160cb1d4739c7237103096118149f9d37f0a312180a90f5237382586d2fc4bf20a5429623cf21256f076e6f242767b790be00e7704a7d40f6fd75613abca5929a7da80473c264fb19b4b56303f252984d4c20bc4c21026db9b323745a938c15ffa36a0e41369919d3eadd7da5f698b84626a37ece815b5e09e6ba381a694949f7ec1672f3553853e18f83ecef84d59f3b0a44215640458d1903da03e9e22d4298078027f8bd0b62fc4f844c534d5275c7a9db02212bf4e5397466ee67d18875df96f5b4745175346571e0d875ba69193a46e8bb34ad6bdd6b8e3b1ce9519639f4554fcccb2d81d8d466a3c569f5889816db15ff8c74cc9308c271bdb920b5cb20e0adba19e101c9d48cceaa67b998b7ff70916a5690fa43c725c078d69e9bcb7e4c487c94c21bd702d197007718c7d6aa8e8ae2f83aa4e189cce36aec6c246e4349eade8788af5fbc952450d774cda55d8b0ab6f6f0e8280b4d0c1664a4af624b2166ea2cfcf5434fd991ddb90e453a25860383e8364cd98ad08526f1f97e07fe0c4157512cba8d149dc52403a9f6d0f0d057c6a5491acc63d88ec45c2a404f3c2d93d2c1502ef8619aa4a80f45aea6648ebd2bbcf332bda2bfd57bc96245d4dff8b36dc2d337dc3a9541202d37a6a44d9e1b04c026839387774cadb68baf4b413d32c2e8e9898a316e19bd4e9f1fc5b532c46f80744b7882c9e7319a0db00d19567e9bf9abaf321322a69c5205bb4842922bdb6ce3da8a4901c48d11eab97263a0a379fe2c6d8bc9674b982184da1835e50b85ef99655f74496ad413613b3833ff146ff90d2ecd8b30d8aaeb76d33e4a322604d91c0ea08c4f43da94bf0126caae883353f75e70ba3bc197324ed502e6c09420099f020c8e1710c73b92872a4041a864b93c9c3fe098e23206301578c9180f4563b0bf0932ac44acdafab8b782b4e15d532228d9022d657377598b4e2d07e6d88e1b4b78bc84ca83b6fa24a8d090878e306d2ac9ee32fa1c21bc780ce23dccff4da28ba10adc69746985070c5e00f8f1df2cc6f15a9dc4aae5ecd9b83b7392fb4769523d8747bcc32e9613b264db510fca8fdec8d2de59959c7d7633dcf710bb6f96fdb5f398c3fd33a794461fd4b20b3bf1d5c9e4bc070876693a827121505b2791fb7e7679c0f4e2048504c986c8b39c625648b52c51b99f0f2cd1512cb7d6ecf06006bfdf602d9153efe288dff9497ea1f9a753510a1cb9030ac9d83f53505dcd85b0f27213321e12d3879241c77bbd486f631d99ee15394fe3fccb36e644261c476ff2cfc2bcc2f3c33c7078c1d851928a275d4521e402ba1d09b0ee733d3d108f37f23ee4985d7eb508a2c26597fd308fe09af12413cf934a741a78ca87a30045d778018b899b973cc6785d8fd6ef3a588a39ebbeb958c9b821d62a2b1924054d9ba09a91a07c9b8ed7eb896d342a5f4185876ecbb48377b8fd972c5f4d0ce83d97c55afeb3606870e08cbe23b4a2a5c46033e6741a4609a3f9cf99792d9fc46722daf003ac6f5d70b1b37671b0f284354e2970be7403dad4203a870214d864676dfb848df761c8dfebfed1974e96da1ca52e5fd08597b1c87912b2a47d85b6e2eb68d5293fd13c7cdc79e048772b3917a9261aa5e56704f1e462c21229be3e5af6e7bb9acffec9c7aa5f6861cffd2f755d1b3e658a45bd0ed61d354624484eb2efe043eaf5fa359bcddc54b6b8a9238d4f2a1a177bb632d6ab5812051d6230c9c01f3be6c7a9218164bb0afa578cc5cc980d3300717e82c81cb60b0a975247072ee59787c638ccf83f336fbf135f6a2bddae6e11dbd4a50f4ba9ddc64187a95d0364e42b379c975bc931d044fcb5cb62a7285181721af2ed312ddd98045f6538143cc0620a2bfa360c6df452f0f6499eead997dfe149a3316218c0d3820bf8ec7c0651d8d76af51d775da09941035051c07fb497fd3c2f7c46a36ca85e25e2cc688ff47303e082d1b5cdf46b34a6267d0e4167883b438260aa27cdf3e36207b9ea6f3c93e03915f281132deb4ab253ddac8bc61a3852f5347eea2343ae2fdbb6e88ad3e1a7947f3c5e19fe5c6bb01457fe1b6123eff1640d321fe5ff5e3d13f43e79a212165e9d472389aeb11cdb0fc7eaeec242149adc19f418ef55f2f8abaf1a43541d386ffdde95fdd68a01b7582065acbc3d673d37d92e160e7131615372007e7b909dff3a225aca6cd9bd4195228b758066c3e216c020fcd0dbce841a65c27478e76ef32bb6e477ed24ef6d935d5672af819d5d7c03ae6203858f64ca0440eacee40410898de41f0463545cad405d1f66a8c54af19802ef59e1b02bc25d28647bfe37c507de79c88b87f63a341f3f26a6f878e0ed9a1be789c1cbd03f92b4640ffcde7bfaa272b1768a3b87cdeb1cc048b2398367a2a38cec2ed8910398de66920bed71a4993561d587bcb49076d84733db26a65d26f9ba43981c3f65962c7aa7df0f0ddfdb24b602dbb11a71d6a7f1d2e313ea6ac78129f1e4489360ec7757b33adab71c3ab5b758d877a02de41e913caa4f45b7d569f2ff89630aa32ad94ab9aef330ab20961cf10b8cf94f4f262924f701f996de25ee5c7fe48700ef96704a3c3a1ca260560075717c9c1d65a0082ccbe8b042d48b9eea92b373eaa5f519f6708c4efc67aa26b298b7f5e1f4509a02d8ae89069eda31e51010415597c0aa19f528500f57aacc9b59d522670f8ea9ab650819acfb2aedbccf48ed3579f486e2e196aa00c2d8046e6bd0ede5aba2d33505fc2a5812bf2eda2f53335c53e9c51c94b2b8c6b9499af49438ff9daa60d1d767870183263e2f2771a355507619c7b860cc63085d47023c404a32df584739ef0bfa01ecdc2e8bcc473e853cf76b9e4685ffb37acb29bb05edbdaacc0bc53d3e6fbb49d430089d6b1bbe6a731d6e97e0869d6edd06527307fef9d5d580dc4f5c36654d0f324480a02002955a13f2f48c8928a79536c4d8b9943ccf1e3abfde41f9788a104675dcb707883319b5b7516638f56c41329a50d9a50cd1cc369370fd18a5637cf3792121edcaf47cd4704038cb1b52908135b6caab436a1920078279216aebb69af60e1319fbc577496e51345a8464b11b489289f5492d6e02f9d526c6169f10fb0a4feb8be6ba8819f2ffbfd4f182a269afda7d086f45b47f6b48308238323316fdd0a790b7fc5112da20f540e0e0f6bbdd7f0ae6dc302344539b7a5b8d03cb5071e38b40f0e8979934e012c0ce9199e1e942f50b731ad1425fe22743c424d794c75aec200f196235a051cf394ccf9a43df5dc20233247e334bdfe617dd09c2f65fddc187260617fa3af0974e7077c96cefc2a580abe62d8ecfae93bbe2dc0b89cc6ce7035659771d31fd25c849af8340be348912b06dd847bf68263989b6225f20e1fbdf82aff3237e560f60ed96eb781ec8458fc1e05a287bec2479667d0a425993788da154db60e93f83291ccd862685f3369c0888b6e2731cf98a980fc7c0913c9e3f855a1932ba2a3aa77e35be3f2ab01c24fc691253c337586c4f0ed8ae5f89a0377b53f676fb8f516fe9d11c191a668367ce050322d9457a4303165ccc1a1ba003159b57328a353035ff574dd058d787b077b4078de9f5167df5658899f7f6b079469344b91832454c21d73e9d84bc657b73cc4129bad313ff5640dc452fba6f3e7658a1e3a5eec91914525d0cde786feebf97f6f2357d79036b23a0f1c69848d2e3c77890a2cef3046f6226c99a77b433f595336708c6df672fd89bde63c6b04876648703b959bbc063d04aba0b4e520ad38f7ce52bb65d952f9438e5c39b1d781ab2a95c25ff197fe65fff1012c0a2b3b8e06d8e18c42b9933e136fb6d02637f039ed552b92310e39dc5a614c8a3f1fb15dcd95a55f2a00b9d3d19318f11b14c98a0c6c293cb2c8173c72e089824d98779e2147d3b727e4db77fabdae256563d057272e1e752f25823960558ebbbc7b1671451a8b9018ae0e2d5282ce7e3938557cb4a6c18d7936af7f64c52922f09afc8e4ae6449b11a653bd3d77df2d744a8c0436a1e69429e9bafbabaedecddd2fec45c51058234562a3ea87242fb90026059ddb4419e345f752a4d7daf9bf72a67df80f6078784919097636ff697de2afbdb26989fae626bab2f2eec995437a43c5394d362f17f8cf9727f27537a62a74c015d06b7ccad10ee5b192d22b935d72583b822eeef20a6f791f0b3d46496af84550e028abf6aaf773fc8b803d3b086f4114d20045f2ce85a4cd4181f34236636f4aee4efa7a36d3b66af54c6e9109c1cec8b5915713da08e3506b69cae302d2473e3080629d47ee83d6087ed9050240f4a09b0618c24f7141958e05ebffcdc5db8e002c58f3a188e17fdd22c648fd61bd24ac6bc2c7d1c7feedd2ec5d6208f0da27b0dd94822d14de731bc5b7548888714f65e67db07d20b7b3b80e05b4862ca98a222ee269107f661e247f65ec6260606054cdb68684a0434eef5373572ecd6ba71a62dadf8fb640ae3592c178432dc2a514b222289f938993ee9ba48eb766f8d7bca5a7e7d5981225ba5a416df5aab97ead5665e27b68f150896a0af6adda760461be6210280805b6a76f633f7950ad06d93790163e8f6e3f29c177ac4be721cada7ea31ed806b765f632d50b836da97b588c096c985045fc826b2703ca2f24691370e8dcb1da42641506a10cdecbb0197c6040510dc566cc38f28cd76e956a34fa388dc3597879ae69621f83fee87db028368b29cb896e97efe7e3a4a65490d17361ad5dedacc1eb87fabcec8296308afd4e569e1eb2d94f6a017546d6ab17a2364b450dde5f18895d4077d1fe565899159351295a510dd0a097eda50e6b0898ae26bae0d7c6c09907203d4b3bf6a1e41ca5383317f43cc13fc0508a5f8051163435141617baa8f1e562b170e9031eccad382b5070c3782322aff91cdb9977db27c9c2261f5ae738cd51e21916006a1f5251d28251c2bdf72d50d79921adcd128f0350c9fb44a87ad3975c2c9f203a67d83aaf2b5c5273cfa26d7a653654edb22d9ab1c5b76eaaa7716daca7fb1e10f38ed013af210a5d20a6c824716cc27184f3a0d3647db825f27d91d39050195451cbe13a0a2e9b2ccb539ead7540427dcfe7708ef348a9caacd2d007ff00f0456b183d190847d8e31343eac005620d02a4fda98c3e47d79280cfe4024875e804ca4e20a51ec11c31852f4bc847c3c82fc2875b4fec5b72c3e91ecf16be7753f63c6c6d4202afe47d216af9d9e9709b9090ae03292c573080d0ea23f440bba2bbe609ea3b20f69b1a74ebe03dbbbb0853d622ed53c0619d5874c2a0e0ea9f990d1385ac922fc48ada759cee57984df971e43cbf14abc1cb3953f16de19c1340940d55ff437e1d7159c383aa0b9dbef846b20d1ffa5b2b7624f03d2cb1ed4cd9f637885c0d270652d797974b0834f9f3c35de0acfd3b1d7e12590b68b4ebdfcda2ba3ba374e6c2289581618a6546a3c9712cb76e33dd3584ebe2ac4cf89485126ab3a446b48f6e6d56b063a15fad7d6aea26c452755f47fbe3442527cd8b2df9beed33995edff2fedd07df559ee8d14eeaa73af699223a115d9bf7169fa0458e6d03371ce3fcceec0e88f61f4ddc89f5142f045903f5c680af21b7d96a8653b1bf1f7263d6dbaf118af6c8b132120825713a0f9213393d4023c866047e24c70aa146ed35df0e7849266e12ad7aea56fe9876986cf2d27d7dde976073c69caaf2421ff99a0dc087aa8b7efb8a9b81c67c2ced7f0d21b401ab9d5d697972d6e8f1c8f25cb3618e714e92348967e44ced0daab7f6eabfe4fd9eb63b6cc96220624566b27430f507b994693358fc9137aa9388fa9af849ddec85195137ca2dd96c3af23b5c7bf7d2d98095c4008cddd60457fcd06981c34d88b8a42b0e9ac6c033fff51c5d73c4a3d343326c96a2fdc94b2f8ee777c8b95a96d786e39f3819be0fc262a41f5287658b14d0c6e718a4ddec09f3363ae2d4e17df11b00c46414f616838ecef64b74b52a57f2f5836c5c15a1be5546eaed73e347ff0c3b586822d9ea90f133b9e4266ce9cf9f9b0883fc7386f617606b951f179cd98d9846ad528dea427cd869f0539dc61212b9a6d64a463533c82cb317a6b35544bb2203149b894c299e003d19cd735bd8395a1df469969c895ceabf5f2919643efcc4ea03b5aecefe7405f4218c4c4c4c3ff11cce8e55ae47779835e77c90230f14cb4879b40d488bb16e061f537abd136f30a19bfdf70da04419e592d71a6ade014ab85ac1f341f494b9e19c098fb1b2c8421529b2cc01e8c18feaccb4ca859f7feecf58274e76fd038d6ed009b0280b3b05428fc3c9ddf1df67c43647085a1e2391f8e8969d6ca900a5173d3b00eb107d9820c49c464ac73e86798f7d11cdd91685c88d7f19c4bc12e0aa5bf50a42933c2f7e141b8b2ea7108b14dd99c2a13e48c87ac93db2ece49722508c2a771416bc89373d0faecb8da9bb43e65223abf833ab06a36533f6b3a70de0bc2cd0d2a4a74767e58888555e116fdd743bbc55c0d69cd383c792891858fe1b263c5926da496c3787d170eafff6c2b4c4571a4c6a432aa8ebe43eb966b8b50887da37f3ab7d80eecf0c22a665833849ee6b3c5e79703ed03e8ce3122184daee05bcfa938ec585a7c01fea3d21ef772a513d17e515a3dc8d1710a79a5e2071c17f1a554435988ead67e72c2dc9c397e779bee313ff84f4e3d259a9f4ef4a27ab114202857c318627f4cdecb1fb5b07ccb97214e183cd976a408f7eb9515411de5411399c3960df9ca596624503e0bfe4b0096fbd54f79e5ce8a321170e1200ea842c5402ec70803fce998a88773d11abbbb84dbe339101499bee349a262737c3510bca5120af20abf1d6813696d7f60d881dd83ebeba35983b735958182d9dcc07ba5135b679fbf9b2a91be27310e49ab490f1cc4894f8017902ee211fcdda4b6657fe0da009b10c28225a8ec7ce13f141e48af36180aafdb66cfc86d44e681fc2a9b8c480288b690d464bbfe2d114e75f959973f9e971b7e94826479dd50baa9607ae3731243e2d692dc21d231ca21a8b889399285db06035178efdc9d5b993c7715c88b4f0e928d2d8d1978bb1e9a7667421af6e7b1ebf77f2a9be0153c690d3997877d360a65ef92b49f027bd9ae958e6fb904a08d0a7f56acf659bfc98f18950f9107acea87cf62397fde3770352b7f70ab5ad7b70af99e4f767d3a02e7817547b799dbeb20d8184738400686ebeabcbae0ff6cd65b5038c7b08665f676ff2b101e03ec578d2bff768beadadf35b1b3d740d28cc0888391c2055e547dbe9a07a3ddd51357c641dc01d21c3f4619a324c10a69af8feb6a54bc4f39956789f581f4b60dfbf5b24dd97328859a831cccc630910202b7d6671812fed97a5f1e227d952eca6565056be44b2f42e41f6caedb1bc9cc774dfd538e6c1adc358d26d4a8135c180acb12a4b8cb2baab19ab74e6a32e5e8ec9d230998ba7c2f54d860d9502f3463e0529e03eb00d0a6a824c83da0054561da7d3450af87c90abb7880ce4d6a0dd8ee72fac8f33462db085c123e36dd35a62c0f83917e392fb24dc72c09f7800aad1aedfcf8e8442ede0863b667dc0f60d73adcbaec62b0f635ef6f63481a42077441dba284574440adda6831c956aa7bc29b04db4f315e1a3f9013e4a7acb22ba601b0fb505b3b02c38d1977f4d0a3a0b9d9978446c5a80a79c595f7ba3460493d1de11c86a694a8df1ba75a8bc1a21b7ccdc9c77b66ffb9fe20aad77edd2609fee2936861c803fee5c62ddc18149827dfc68095306ef50af99c20ebb7c5aedd4998ed8c84b6a9c140e7303feb79b1cd5c181093ce096c48b71a02d5ce2f2a0cdc449ea4fd2e90d3e1767cdb44a6c94aebe540b7f8dd3148a04bd81d13b103647e345636d2ae4a8fadc273ab21b5947a4ea552b57fe17a08ea9d11e239fac2899f2f5325a34453b47941eb279592a9a68c6ddf2d9f45187636f350c59e35023e7ea44770daa477423a4a32645c332f7f8ff08e12531f132a89ef523a2b6e4853ee0c65dea53eb2d4bc2fd263cb63255d6a00d531f7308cb276531ce26c067adf180e363ca980fa7daaa34c9c7bab5644c37fccd27db0c48abd61895f5e1878c3ac021080721dfce0e0d0e5a5cb2be7a01158d169f34abce3aca706cfe57705f33356f79bc7a24b565d7c24e256ce1d369be183a94962fa5c321f582acca47b6805bb43cbc67a5492068a557f13d7887e47e2f92921c23cbbcc6d5457369c47697bfd2e1774bb4d846690c90d8f8d2c94533bdc99835dfca1657bcada79d76cbd916601b70bf42f1949976f93a12e09ff6b3df047d63d13fcdec7587134762b2c42e4968d0811c5bfeeb53ba133421376d2d7c244a7e3ea012e1edef17991175919984b3779254a9a7d319e9ed15129f9723900bef41b85105a01b49b0ba63104dc6936f37f59841b552e17adca4a3032675b2683d43d0c7afedde9802dadbe1b8c8e7cc43dfc2af74bfa7ddab855a58e9c9600302bbd9f96f97a564972f842514113f55279600019d30ca7ffcb84b01bd3dd0e08c5561ddeefa1fe02a1f0a171ddbedc1190fbade6fcdc1da8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c8468bfdae736e04c92ec57ec57c68df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
