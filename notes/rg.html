<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5a9b96826f6bee899d313e65b85f20afc5301a0ae0abc5eb94231f86da15b678d022ddc6fd20c2fed9a4fc0bf5f153bf670f5515e6045c2f08828a19270546c52b05c6d61816aed059eac5ad9baa0e754311db1608522967b8de08685cff18ec9900d49cf06a6d683048ce2794a6a1a63dd7c726563bfcfc9fef48b05c6b9eac96a1a27b528b410cce8f1b030c2755da6853a99ac5e44b7636e8bd3b109ef050d208ed200103d3a82d6cfea3330fbfa3ba34df7da36e778c826dc33d05e12416169ada10bd6384e3c9cbdc35011fcfd3c59885bd5a4766b104cb1714f5dacf067cd5292c7a3f048b3959bdc547cf218dea0861e2c485f252ffa4d8c47a3940f23780c5cbd00cfd1a2051c52b546eeffb4a19092ff95e0b97fcdc0cf7153032d929b4b94b3a729767f7e49f219c604996512e0d76efd61a8c93bf98b690d37a69c4ebd17c5944474b8439e94f3042f153b2ced00f6d5b43621d2690864dea62911a787b90ce960a8bb18be34f25072a98dc686455921c2dcd64af6d2ae925b3a61d76926a224d473f17660a69be836f0156485659d5751534704aa9b8ec7f9c0f41e2b114182788e36484c35ee14d1aa84c801bc5a7fe4a419f8d3d5a21ecdf5d0ac089c0f7b060e6c261651c925a70fbd11a1989a647c0715c4415b41793a4a74b7e48d3b21fa80c84ef5a0b754a2340b0b32e3a1574a391e6c1a117220950498b02cfba89531276e238bec495cb145ead93de62c25d13cbbddedab7519a30c0eac3215d2cf3220a3d9c2bf158e5ceca2073e944f49ed408ea7d34d985250dde2502cd126df3c3b9a4b8fe2e6ee388a23dcccd8c17e1328b825027227e6e86db21a6b82c127161394da8d4cece364f038fe72069c8c9f32898b2e20c6d7a9f6811c8124e0448282a98e81ef82c67ee1b176caf87a242d70fe9d495a2c11a72d5daa1f40b3eab61618d3744413f968e019dc74650d6fe6bd0249629b25814876181e01cfcc82145af69bbefd9dfbb7941df8e468717e2947342491c32408b2417fb45ad0c82b97e020e9eb29bbac7bf782a66e30f16cce099e54118cfeb92872ab575910b9efbcd7e0bd20d3935c20588d65e2124458fb89e6291b9161d616bd425018ff7e0a9648d20b428b93eed37614fba7c5355e152d7a3425ce0f18dc2eb13207e16820ec1931e8a44e219e44a19c4f4195909593c7efc3faec08ac455a7bb3559a287e58e04fbe957d78b75b83e66f6e123efc07c91e38bac70b944d42e827dc09a7760bec08dc99490d222b9b157165e14518e00ae3ba67682caa0f9f11ea1b1b30bf1648f062c97c0cfb2a64bdf93d1022cd29bb435865ac82475452237b084649437aa91a13f0d62254a6c773b5ea7ef40667811b1ca2a739654be876ef0c35bebe41ff22b8d8fa477150a2ed4a30d6693eb3025efb9299f8f8faa9007db860d3ed4ec60e5a6c1b0bdf796af47a6f40e3e472f1cef0ea19fe67fbfb0dad2e1fd6360919afa3d3cd2cb09f8e4915634a3b6dd3b840aaf37fd99e34f60c4fe42f600117c411c19443826fe55c2fb8028352b15907e4fa41b4ee21a395d8fe526c99f050c9501d833372c8c67cb695e67a26ca7948513953d1476d5a13609fbd4102b55329a913cc6e62ed8445c9e328dd6028bfa20945c11880a0123ade989171d6968a8e3bee3919bdfd2aa468644dd2d5b5e53165df141b522e1549841e54704eb675718a38f4ccaf28ccdea2d8e4d84113d33d456bf7cdb3e26257ff7dd437394e4468131dd096aa641eaf3cac55f5061e2372cb278fb053348f49f8f1b14d4e32ff1c9383e916af14270aeb9db1cfa6d4ecb122fc5a289b3ec3f7532d5261ebbaef28cef0d50ca450d3f54e80650894ff86146afefbe686750096980071adffdfc52717effd366fcdb116d41d8897eff8eaf08c38384c816bc5f722eabe7eb2e93cb3413e2e8d43510f2dcd8f7f1ad314b1c1fa65439ada4297e04d580de6b3e037e6fe352f215be8f114ef5745190e13b1cbf3fbff8aa3dfd16f247de2c570c851ff8b1582bdaf11a4b8a04f62c6bca833847d3391ebdba2ad1b472fde7dcebdc9f6680e131d50be4cc56315810ea6f87e7d91fd3909e7ed2257d18c3530fd8bfb84f3791917d9a3c98f4626509e7ddc2fb31b0fee6eb43c07957ebc111579282ec164e3ea166221e8ed44be9e6d392a5b4112d5cc9e30ddf273b96ac8f3496c0bbc805c6d62d37bf98e8d2f623ca0fb70d6af4f6cf6c7890c82925eeb9f7ab7b80d341e0093d1dc176b74d46fac90cbb79bbdf5dc0da8781e9c4f3752460b4467ae21caa875a95ff6d1180565618b31c51d98c6f0f5d46a8de2ff0d77dcaeec53a89184c37b030f6df8eb892b2e6cc0be9e583050aa3160ec711d589281217e8aae76cd6ed59bdc4eb56fa658802aa6797571178f82208ae8f4d4135f3f1c881849c12273c221326573845c5f77f5ffd6f3c0344a8898a9216857cacd1972b0fd2e614ae9206d1a9d3e067120719c2e918a26ddf7327456a85c6b59eb086b745b7088aadab8bb5c07ff47ccfbfdb17a24b8a9ef4a42c354417425962190184f1cfdb6fa66c00bb50d2cccde1acaec571434b86e230e827d6827fb5aef492e0552855149d07bec77e77ed378d71b35469eac1991ad86dc82f03ccea4c83db9662cf959f525b88922047d5690bc6e8ad7557a7403bf8b0d7bba073c9217118cbf9478c3c2155b5c1157c6dc441e1aee78c409ea3c924eff138209592ae9ffe6d2ab995511d61eaa3a6f99388d3dfb360a97951d08b0f07fe2f33e814bfd80470080af45b8a3ef3c2310b6b1393400f4df63e200c8f934b2f7a5ec5f5d78d07c91eb62f25caeeabf2af7935308ae80e1f106d82af37a068aa4f1aea154828f34c61a01fa021a6e5c812954837566f3b438f3626e1cd5e2e616a2da772b17d3354e227a9ff03f594b13f8a954a935ba4fae32657b0df76fa6ba14e66dcb48219bfa5a64c942cccfbf5328497ae2e5938e8dcbe918b9e1dd11a7fff83ca2a9faa02160f2ae8a587b3d12f5bcc5ae89fe50f5f4dbf1c5eed808ebee384961cdcddeadef8b9eb6825d789cda2f665f23b999e98414798a41050083f38f8fdab0b604268ecef24de1e16bb3d07686277e1e6b3c110b8c46795ced484537638c95897ff3366a0f9d9749b9722afe3c60a5f4372e4aa5a2456005ca1ab5acdba6534232a0cbbf6331bb6f5f3f8871f22b8a6d9c921450fca3fc36bf29d54787596fcceeb9af79e5138160efd60a8500a64bcc9ad8788666baf9493db2aa6976b8ae189b3bd613548717e94b8aefa5897059fe2983f62e24efb7ba718348f21dba3b2a494d4ce320dcd7ebb012c38ced8711ce5d70590a87d050257455c740ce4b844cc03308a9f4f82a3b2d5418bbe5742c36a9f19904663ea350d9ded10e0f8707f545e97075a226a46a9f09c0d8a900971c179b4ab6331949b1f63bd9022ceac5918f9335fefa715064304ba6ff9eff1dee241d9d7aa2c82917bfb20cc905935e89ad3319508f887368b0b124af5233725c8b854057084466cfd53526f2564ddc101d43cda9583b55d78172a6ac6e14f21df8ca614a0a61407744732484552f434b70b798f218db3661e334b79fa31a732fb4a4eff3dc19bab403570513cbff6c0abcadc167e981beb3fd137a2932c0e0f36e09685aba1d192b08c46d1ac4b5474902d48e60e4936c25005bf11aa26a19f476d843f2267e38fa36878e59ac955b9ed507a3930467d5176a298a9162d32076aa59a2fed43184625d4a9bce012402c64e6581a1ec03465d5d946b44ce3db368c71d54fbda860b310505adbfe635695f7a73370a17fdb3b098df119c2dd1c55e2516e4bc312e31775a5fcadd6b098cfa69ff8f04b79e6980cf32e828701bf627a19b5d8f37126b308d944d0d5a95b03d02999830841f414b7192ad2861f307631439aa6d828888941ea12acbc9c0ca176461b9821f2641e5bd7f5691df96e5d7811304a6294b20913be43b86eb3a274a51fa4e968b42a121651914f74e86818a47d388a943def2ccf38d4aa6bab3fb928cc0ac66caca0964b4895328f12c9fba0b91a37e83e0470e0593417ebd4769edc87a532cf79576b1ed756e417949b5efcb6b8163afe4772a5d4a8a859b9ed701fb17a2f9cb40cb554c4b9386ebd6fa7749a7384478cd8595575d384e6b9e9b1927361e781f146b64c87a46324c9e386bf5891bddf9f46dbcf5f97b51f0e93b4cee2218693c7d57f79ba22b9c96505e296f30ce23dd449c796924f400169a325ec730b413fa28f72ae019d101b08fbcf8da4d174d20b127d873866066646c485d23fb082887a1dd421e9bffd1a35acf1439904ab6eaedb91d1bb8082c79cf30758d2ccfc94513ddbb707e9bfef75f7b5dd193dd4a1f3b67c1e287f56425270fc22b083e9542b050231c17014411ab33a3155e79cd737bdf9b2cffdeb8b85865d32773ee07134f8329cf5f5d58582cd8431e25a62baa0f737794a002fdb0271362a1f9bc42d7d6551b6fe1dfbba76bdb17ee948ccfa9f8299044f6499ed780deb4f45ba893a943e004d139b29aea22e828e9f27c53f78600a039d52e346f27f5ee1df49810f6c5697d3954ef3210f29d2ed91f1fa8fe56961cc2370ead08878b5c27fffbefc149fddee0d8f35c2d2c19cb18ffd43ad0e7c1e41f010abe90ecb057079f2ac2324f970e3a78fa3ea09a3c3f7af6ffcf71f464447ca44d646938f66cf5e6cc0c325c1b082a05101121979395173f4fa182962180f44ecc0806edae520a64cd7c603ec83f172cc48aacae87555c5689ba7802bbfd58bf6246261e707384e2b868ec44886971477491839d770fa26fc2c81df1db62eabe6e0738f8dd41221815a33bacf9fff54f46c0cdce4c9d3d0516abea9d9dd41921eff20ef31d950d009df1a76083bb1f64f92b7a4e4478cfaafa3c09858bbfa5ad7f3445df875a129c9a94ae9297e791067edee7cf8e9a55807f93e3c33dd7486db0550fdcd96594d954df175146c8d658da7a162ed4acc171a8719842a644e859539382f4d795c4ded27973456302d1c19a200ffe5636910ebaeef73ca8711428e4ae63a2f385f36734acbdaf9b56cd0ffc152afa003bd2906926802f9cee2704b12cef7ae6c9c94f5f575fc31f4eebba9fb44abe1c749a74432cc1f033123aa4ab3c1d05c8103129c63b86bc801af1c4152410cd49e68b53c2cc1ebfa79cb34cb4c65c1f658e52ddc300a1e3e3220f0125d3e6f8abdc66d07c2690e172ae12c64808e90411a4901cc15230437e3e192888596a83576b04b687c21c6c3bcb65a31018915f76e21f199b6ed3038a95a5c968c069f47582d58a0c61fe926686e235b514d7cb49d0f3bb39bf30456fa89f6748d07e6d931ffe93e688e174d37b223a0cd08bd9ee76e74ca45d4125e90aacb8edcb347901efa811824efcc52551ff52355ece77cc5ea486e9c9a99e4415afeff56b5bd11077a032660cbd7a2cb0f6ba705b8d28f05480c061bbbc6ad9d1d491f0baeff03d7e3283f48c86e3674c5b824a0289155cfb4f60abb550948f9101a05d0b2eb27e8b52752f99bf176d52e1af5202c0a69f586c7258b025275f3ae6312a47164de87f7c05edbbbb77ca4b27de1065a052af796370d68d3c027dd749c0b9928def2e9769b22640529a7ecec68e840a69b97dbcbd0d5b5a39f4b8d822582108d9de14b2e1bad09b7d975beb2a0cd6cd9500a9bab48deea886409811af9942293b9c45d02f4b1ada3ad4c4539929a01d7c6859c35fec3aebcc3f2a8e32f74da4533b43fc21f34b53871b81098a54c747f8aae60880071839dc5f54350328c320b3314145750cef9096ae32aaaf97e6b4630ace901df67a4c978fc64848a2c8b9f3ea3e1707fe3ccd682bf4a59a28bda173bc71535c6fee74e4f240fd23694e17cc9d963ad687680fbc991d7320ebaf85ab42d17957613f057b81f01229a1748f16bcd7f73267950bd9b5e016cd797fea18bf1a8ae69861c314dbc698c8cc367ed2bebce82274c0c6ce04aea56e81c5bd97b3e268d2c9cbd3648dc77a94595445e2fabb462f6139b1172901f6684dadcf46310fdb129517eec160a94bfc062c5c24fea9d79e88c6b8a18acfa769ce2a24c9dc3bc7b7df202869ad2126ab2411a83daec9e4f4c25f560fc7c5ae8b873320701d545a5ca352f761ad8d7ddba13530943362f198b62ed47304bf37a960cf51347937d44c0c11d130dd72caf281a4fb9d37fcfbccbc7eb4b5515d58f92eb163999470bb2b3667414a4e74cf5ad89fe94ac52bcd05ebe67a144edc1c46132a50309e7ce273ecf31bd2d9ef32f1bd3710067c16f100b11a9ce339c97858b22d385e3f1d25f32bf791582a0377a1e6f1f189b62a939f50e3d2ebff9ce2732e18c9da0aa22cbeb7e7f4871f52f0e1eb0b79013c85d7d93322a3c9809686e5aa998587eed8f547e9fb13fd77aa662b6a9572a448ebad9dcc4a6d0777e54378c8180b92a0845f0bb593c12c00b824bdf0ba7e26f3ae2dd25900d6b87750f2c142b0bd014fe6b34b8253d3366194dc9bfa1da1d9200747908d738f2c40a05f02c541003edff135d2743506ec736090c53748f91f25c167d31f6af8585bb556c567baa7ab0afad3558de85c03bb65398ab32aad2071d96c62374bec6060c0d6204cc22a59d09cb39caf84b17e5b37609939fcb69738f3e07b47432d27bd3b6e9e10b54bef8db0072cebe1ac478dc20d970fc6b9a859340c1f44ce0d037b62144a7e676bf31826a1509b9369048d5736a3f4a05e76ff306042f2711fc38574d6c73279d46d68b26733da79bdcfbc02dc1560a0ef155c12e602c9af158213f88ff9ddc890b4e9a784773660ad32b88117789166977ab512fa2b3ba78d443fbfc6dfca05afc91acc558949c269f64decba5caea58c0bc23a4ccf9de7b74dbabfbb6a68e05f9b92b94f34da8db34da7af2c42ce95ef070ba8fcae5aeafc515ca630f1b81eb06d29028fbe3627523a731094c142b9d111c761d16872a55ae8f290a9dcf473d6c5972dcd235d2f71b53bb66f8929d50a66a30b0fec488e479082ccdf944840c5e3d34554b99c0234ce19ec34f63f7aee3db861b4d6d82e5237cd9d2db22bf1cdf650a9e7e03f48e10c7f30302062ea63be9facf8c3c0d854df895f8ef8fa2bd61f811cb976e1f1e2f56a89f956961f46874bd2165cff93748c8def4308defb56574e435e76d3a7f3355cd292fdd6d45d86a3baa84847562a29057b22ba3766a5dddc576155bf5fd0c64913226c8deea2099dd64c3986bb5a0ac5608616442eb3a0e84433174b32202aa6e6741e4aaad8cb4af25e678393928eb40a027416e23e3a78af8406cbdba3e50059ebcc51fdb34fcbe4dd7f1d2263ecc7b36cb6e6c24810c2964935aa590c6e8cacd6cd0ca4fb32fb1c85384a18b1cef8f68b50f21c44ac6f755c2a5ce594388fd717ffd2aca5c6d3d2a5bee5773b2e23d9c0c8cac22ddccb3fe10646fbc6e8c3ebb67b22fae82e7a978a77ed8d33fed469a7824deb82d8df99bb198b01b6844738b34c0e830a09e90c31c26b7e918e97613b680cba6f515711222b047b7e742b8bd964e31e5ad233ad6a7accea6736e2213c4396deb4a3107f2c30da2e335e18e2061176b8a2c36d36950908acafa26d41732b8a9d14fb5fc83f9d1bd8b4ca7a981753628892f002fab8d848debe247050de150ca9a4837d44f1bf25598bb31a36146bf212f10dcffd31cd675edcc1fe2ac5b4147560b0ae5fa083ee9bdf5552952a10595108ecc77b9ab4675bfe1d95940fe2a683b97f56d1d37739040ca2bd3c3b014359d487036adadaaba420f467643d8c1b62a6b2cf99b33a5b5d070f0b759442989a6aba19abf76cf12a78979530406fb685b15727556f47d8b7e870f0ebc28ba31af30ffc31349d830d24b0de7dc55e6de788e506cbb5291f3c8bf6a21d7637f00c3def6553be3536a2f8e72145fc6b68880382f85379a345735978b3f00b2b0467b6a6187b29013f0a65a9a93660c71a46d402779a05406c58a117c278247bfef8f0d94cfbf4c6ee36a13d2165b0a520d0202c230d982ab286ef73271dff305bb8423a44257ea5658837ebc965467fecac3a5d0bf57829a325c1fcf8ac4972732422229f8a7ab399e7bc40189d29122ecb4a14affda8bdb83ef84e2bb129437a8918cb79184c1b6f377d091b3a1b596f801d387c44eb33ef83706ea6a0823d223b599383ec8ac08cb4e2f169e3fa6819dd6f8a740d214e142d37928d1b7fc704388c849642faa1d67dacf24768212da0a1c63152e0ba1e076e6f85a5f2743318c7ea3cd157c1cd9a901c768775218a29e8d25fa77673eac8720d6c8870dde0a2bcf857ce560695ba9476ee4712792f57a95004f582e4413dd11a4508dd574fe9c39fe345c9c6c77caff9e9d77992dd931da1356d74d5fd641b234db63b205b799289d9c5dc9d93a9cde0a7ba86affc62785dc042340630d39f06267b22259c34e2a95aac11ea6bb189b9996bee6b201fe400b121bfc1d61d0bd3cffc4b982a1178178a1f6d935852a200ce6d3c5f684e501f69b92eab994155e3d54506d38e759b17265907f59605f2fe1d0061edd6ff2aedd697f5865c094cd8e6aff253937062e3915169d0731bc6d67d9856034e28ebbee1ac30f2f95e24aa07035198ecf5f990654d2cf44d2fbd885ceffbd15d26eef23b0835f664c788fa473612eafafb7c7df785a2b6ce38f850a7613a9bdd7332b1fea24a1ab968465126045f2f1392e9028af559072bceb910efab8b0d5b5e639f1a03ecf6e306c9aa60ce4d597723b76393e5bee27955d76f59dcf8ce2071467c0dde6c8a5be4284ee4ca5ccd00e2a3f6ff67e2a53bda29ee118453a409e31936f28457dfdd5960118f28deb52b4ac273d9c9449038b3cd58a961549ba76a2e9d7c3d26e52cbb7c43d4fe4850216297ad39399e18a08ff236d411cf0a41b49751b0bd75e82fcdacd26bc7a78ea328d3dd754bf3b50e11743564ce71679c3f3b971c4079c03596da5de64af2d4862c6bb191b01d86e69dde9e55326ea1958567a45579fb58a558da87621279413da818dadd57eed2caad30c39219822e7c37ba4bf61ce94b2019250e6979273c4b73935d409929031e4bc7b9c145db74d5100c5a54b6e0fa7312d11ef5eb99f2686cdf0771d19e032cfc10cabb8c0a553c34ee0d4be896c0acc8e8497ba700836205c150fd0314e63c46a84664e5074a6179e524a7021de49e816ad5c0e2c9f6f7d4668e5927f8d78b14990c62e83662bb3e993a656d8636c3e1181a7bf9bfa4b45ad94b27d84e0fc65fe2ac3fee36224aa36afdb2bae81b436215f1606e5cff91bc73fb48807f13ef81f291a6ee8804c046137e53a540238ff53628e7b31b97d8485d05d1e20f2d1b934c7e69187403a9217ab9aab0303349598759982d7de6da16df8ea990744811b0439e5fd073dec514e8d5a4b5cdb051aa6f70bafba3c531c73943c963676c58b1827cb3cdbaf5cdcec599a50535e7c6c805adbc39f2167b60b0a40a195021fd5cfb05e8d20129f423babb75b1ad2e7eb204f957fcb22b3557ff2b118fe857abc98d90d792cb555ab894dbff5a4728abbd070ad9e3248d3ef33264ff47a6fea24089712cb9d11a118e76f7efc2a93e82f774ad75a0ceb69888c807feacdcafe34ca7141ea7e23c55b51ff6cc0dce00dfaf46c73c559c1d057a96fcfb14f1c86e73c73470f2ec7583bf557bffbc34c8a69ea65faacfcd34b2aca08d1f7404b8f0a089c6a29bfeb5aa7b493d7bade19099845b2c12f86d25e2e105359c44a7c3fb08bd53d366d1a901f2fe49eef9d0989a80824f57143a4d7024d9d77cb139f100d96ffd1d6262def8331a12e6083d2add71c4aec373e97cae307214593f544966921eed5e8acf5d807f2fed203dadf9c54869e869992a3cd4e52b4197ca8d97425dd1a13c569debabebb87391025c07caac8b8f42585cde315d9d154fc69d3d11c3f79f2cbc81357f3dd29918c0520bba31a72851235778a242fbf46be27184ba46315fbbdb41a5fdf37d60070ac187e1968cdbb6cc35099ac25a213c6bb8460d8a3b28708ff8812feae1083814d76dd660bd32c1dde58b264fc21b0671a6c26ee1c3c523f168a6c95f58ea3cfd131fd2e03ab7dfee4c8b73b55829945768969b23d81e2883bbf66c415c3d47fb541cb6ff30b234804fdb90549917ed99fe2d31245eae62211356d9946aa9b70b4858d829f6454597b3fb8ea13aeb10a3719b200e9553be9d462d50abfc5f7287cc06c676a33610edb8bb3b99763b62d514602037bb05abf612011e4cc28780e73ac0fd91d0544410a8e6c8c8846edcaa040f160560715a080fb8378dba134fb01c6ffb4400bcfc6f1c912a27171eeb27b876886b915ff4ceb21fbf5adb777e26b1b910449bfb3c6876274bb75aede998441845f36de561e3f38f3bf4a4d24b11252be3edcc53b33ca366dc0b3a26ce32554c6e0095e14b38adff673c8bf91ffa343fe86309c4ff6f87b00960b4a33574e56610c2ec0ebd92f2f308f514c8b2d9e03686893365dded0df2f017c6f302fd6e761c7af45100e081beb7dc3444ecb1eb92b0c57d31dfcfedacaabccef902fdf0dc46eb3b0fc04b182c60253e0753691dab5c61cc954feb8e6d0dbf84f954f3511fd9e3c7ec1229ded8813fca3d09e1848e3cf1e0d8107db04810de318c5ae9c9bf2046c51260d030a7bd98fb0d8dd716f30396358b25538792f4687841459a9215a18d4f2b16b3c38cb8f2f306c44a9fa87010254f68d0769abb24e81c9343604a1aae345dfe0989144d2a3c4f141f98fc1f3294a65b6d50d4d80c76be6cac8c0a6e3860d96cb74cdf57ee938753ac6be57ac005e51bbccd43c670e797ef5db305005fbffb71be1a979902ca3dba42ba0be3e1d8b6126fb4dc51b2ebb4dbfd02cb7cf76df9e7955106259144c57aa69f4b09b37105d4f39a20503cca9c12cd8b8a02cb28bb835dd0f4fd3b5ced427a3ce026731a0b858bfc96f533985e72b06f347dcf2743ed24ba0e4abf9201022e366d2bf8f464f8a432e8375485489409edc80ec7fa7e10992c9b147cf0d0f2e03e6c9717fa51c73393ea52ecdec9ac16c1973c4de98812ddb3461a86d3c957539ce678e16042f1f21ba3027a535019eb0aa5a39ac5ec1d51f3f2a3b7545561d1889e1f4429df4dd4369d94a5168942abf3807e184fe3a9c0cf6f35a6790ac3a7749e4405d0339c2370199f73607e60f6fcefa91b5f1ba8fd1fafc2ffd4d98f9440477cb7ebbc4269447eddfad5e4b294f7756c3b11a84655e066151a026b45a2b07b33059ad653cb8a52e8b1faac8c1fbaa16b6a00cc78585a23a4382dfe636b8d4b5193b1ebeda8739dfa3f301c07af9541be5ea7561c80a6d0b6804fb487423195264cdb62f57e5dae4339b64577f2061bddfe8e73c654e5ec648508df7e3b8d3373dab3e46be9989d12f006ef8b7762aa86b0d4ec22a17d4e8101f9844e1f92c01a7332e060637df73a091895b9178bba6926c5c2d061c6d242bb14b211514bdee3c06bc734aace0db91d85d4cea80559971ea6bfcda08d6a5669ad42441104cefae61a6379302f99f9bf37db19bee41b8930c01ac812b74179a1bb2b4b204021b299ad289dc2ca959d98b9e787e74b0f43cd95fb35f3c13d538d926fd517b7f95cb89896f7534aa9728293aa5e10f38444a8c15ca8b172329a85e33b74420c41b073c3e6d6d3f0644a3403cf594e20f47de55b76a3b136cd48491692457698f7bf1ef88f43cb56c03c8ba8c1b9aa81211846ee5c84454a7c499b3c3c6ec094fb15d0e445eeb625d5cfb6442cab03db63cbe51fe570fe04a68b6daf9f8fa8ea2f64a340cbb717332c16e2f9a3fff63e272ecc863a1b4cf5392ff19b0505df800833af1bf8a32d76d3b75b12bdd38ec20f3958d8f872d7dac8bb5106f763f1995decc7377483587adb897da7ca795d97a9c8c9f9ea2ea9f7718b606c494dc0c46502bec3dd2f454b4b0887bfc078debbe8ada84e405ed26e8aeed5087396bf5d3bda2c4ee4048be2c362a4f1d192c98a59955987903bd9e8968f7aad408eb3e4576149d16640859d47a79081784dbd8ede51df87004369a38e4526b13c1300e2ace1ccd4817de1ef1eefe35be5d7d6269b4eac3dc4a02413956d6f8b4f2cd2abe01265cb4d871aabda912d049c5d121e2d28931d8fd3b8d90079ad41289d36e70ceedcc618a1623489dbf61135ff5979d99f53b7e35a2503e2c659c7a9625ea10bb78a9b7e748c8f31a44c9069a06e52a4835a026af537a301e7b3246ca5b6ecb057c062754c331183f0763c44281a062c077fb26ba0aad5f95073e2f4bdeeaf2d67ecf2b7e75de31678125d3e62c7aed57afb375d55b5e544b2613cdb4eadbcac007b8a3b3a049be1c03ef1ff79579c792700735613d7f2bcfcd4c9a8caae4e3a261e2543c9eed790836672bf4817da5020018da85b4e87e18a98b1ed748976ad7e1f936e67627be6e343235d3b167faf894fe25ad959eea1ed8ad4ee4e91a31fe2d6ac267ed05efb9ef38c9f999de64d7d63ee7c39b76480172128ba4fd46f87638fc5a2da61149e9a4afdd37bcdb6c6683c42303dfcdb2cb58e6ec0766be20fe591dd478a2643f8a4e3019af3c362571e1a1cea36b63262bb101a79ff4839b5fe62dbab60f62d9580d4e0130c03c28fea0673dc9305a89d65869e70a17642035fd38dc131acb4bdb3489605119fbe0cd95c87db042a93bbfb2d122cb9929f1529e9e345a22abb850ee5e0bf4e429eac7a47887dce5690f356839a845eb00ecfb83c147b9e5623348c2eb001","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c8468bfdae736e04c92ec57ec57c68df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
