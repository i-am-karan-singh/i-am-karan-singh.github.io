<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8a418c3751892c5e9b53e0e03022520b88b7635f16765f367b7a8fedebbc55cbf15772f42d7aa007637c465037104e03215f7bdac1f38bb756aeb62c56951e640f1aee5071c53abf2a6ff2e9849003f714b070cd1c15b4f2ca78f5a151ad5739b6c5ef26c189178496d185a65f74f645a62f325675e7297ed83f18af637cb3fd8b3b60794a7f353f180e4deb2bd5c06665f70838c21b179f6b60a9223b306ba550969e826fe14c01b88ad5438cf2d4442d781a746fd8aeac82503eb1c1c9521e5fd9beeb2a6befd1a3f70de07e10077310c4ed314e7ee7b2b6123d55740ab8f450e69f5a87c8dbe336d72a77626b09de9233e3ee48f6cb1985d13e3948d7298e6813cee3841c11a5e0f6f1ee751fe39a37feb57afdb50b653654097d2f0b5f6142945475ab8a24368fb48a8930e4654878a26a72d1bf06bc938d6726ea10555b02c8974685d8d611e5fe49ed32af2ffe96d4e87f1d68526b22e00ab4f00fb5e642aa70d9d1684059ae6495270120758c632d91ab3f4c1817c22abbd98d84afa97796a2399315bf1627f0a0c6f78aa20399ec9ccf890a24e36fb44b30cda6f7570ae747660bc5e7d5d877ead0ad6f3e3c08a01e933faefdb051cc99aa153c0bb2dac12121fd103daa9ef926ffe397cd8b716e770335d611c82498af79275b39c21313fbee9e37d430d0f520ea6b16ce5a9daf6496b98857d4ee01bbade5d75b7a4b3bd856a05179a4a2cc966e9aa1167d10eeecb5fe21e8096602b8a4a8efcf2d9a9b0aa91be3747714e78c6385b3933b7174f462861d3d029e8aafcb94ab5942f08118b95e69e334e59d60b01fbf8145bb3282bf2156c6c9d55d21f5d0e6206253110a2166a45d006246b2ddeafa23b7999427885fdd77c912b94f453f1cf170b898e24843dc833ba6c4b3c3e8068093fddb4115352a115bcdec9144c96f5f9708da5c45e9e42463de1d65f040f9460d98a3c1b6ee3b198510ad20161f908ed3ffd1deea78587072dc302f401bf142ce8652899547e25afb0bc96a54582950eaf159332e1af055635135e3d51a68f52dbf476c3332a441880ac383c16bfea1f68253b920a9f6686e4f257a6b2ab62a65f7549881673af215e9858b9e8bf1b781594aa432091beba14efe3d5f34a320bd2ce907ad43724a7f08c6edb990a4b2b37d2f4d3b4677ca1d0df30ed3b6774774f1c1cafe00cf68c915b13b0fe9162514f7a779c4fa4f111927da793f8289e59f0d1ba43d1199ef319e455081c995c52779fd49ecc5184165cd65720703b7f26bb67f056fbb07a2ad9ecd9eb7010a9a600ba0588a2c6b9e65276301834574ea6ba353f0a526505e50dc2aefeae5182b17d1d9a782855fbfc6a82132456962321773390ae26ea6c93b01f51ed6324179e95549353696325975bab4b32426943c0dea95d69c123ffefcb63ee8861b9428294c59621656f7fff6452f652a52897d32f840214e73c02bb38d616d4c18f6dbd73b63c258f95f283b86ea2d1b3765d758f0da55a7459378c6278e0b7cf0e9d23da2c0d77fc86db3cc8d089d3eb3fecf534d75206e00a4c3298f10ecfcc6e1e62c2d577ba9490620bcaf18630dab5a33fe42681cb046483b9c5a8e820964110110aabdddcddf118867ea2ee5b44ef10784ecac4946a4991a87d7e2ccf8f6159944b59756341c5bc7681370e96009016d0108b00d14ed2546036a547c61297c92dbf32d0854b25e272afd636d2156c850406cc1c53a9ee22274bca8e954a13113b036f2938ed6a89d7e6bf1e03ec887dd7cdf2d43cbb62c0d843bd46cb8454702f3332ed21fb41cf86e2c7fcd08592e9765bb033cfab1b362f61b7499a61eae5062a6284e9e00a6608dfd2f75d2c2f3ca47fac03e96649508eb36595977f6d6edf1c2b526ccd646106348c1413dacc23e47a3b6562657063e0f1c60b8e2152fc138d3c949dd99b05e15baba160499be9e57c41882110630d985eb02c0f803f7aca7554145fd81ea8e85680f449d0e9531b0aabaf89e6be45e5927f97a5337a5afd9941a98254cfcf9245bf54a2f1bac05b8c9a4c147f06ac5db43b3cd7a2960e50c4662a71026b84775d29090dd0c9ffad4e159158e1e26f945282add4f7819c335c2296693d97eee834ec511f844c7f67227a3bbb84ce2951de21cdaae618cd2663c8d5df36137f0a94c22d4dca34b672b3b44788c99707ec5793c457fc665b77db0e7bb64db561eb733b5732ccac6e8f841d9497b35625ba70a2db6778e6968b888b179746e776bbd71b4364ac3af9e1aa84707a40202165b8f51fa73ff6097e6cc57a90c3ea6aa14c1af5935133bed2dc399886611f24e243c66a428f006977cf6109e278ce30ff60e59e60930a5054a3b9dac0ac89e410016cc0e69e63089338367924ee21dcb8e447922522b452e785b5293e8ff99115cc3cabb44be34cdd671f04896efad912931d5dfa2ec83104d75bfb3f885a1413b4338b7c12af1ff243a9620bea328c94aab44aedb9b577dbf9bd2dca71e01b289ff51f6b79c0c507a4b5912052d2c2654c79618299e3e6de7287c2033b49fe15e3faafc9bd67fbda3dd1ed6e96031e4ced80802f5d11d36e94c028fdfab25fe1ba302cbbc413b4ea07752fc605755057c439bc6d52edac5f81815b4922d44fe1267675362733db26cf6bec38efd79abd44a106305f5081a305bab7df1390b1ba0787115b90a41bd0e26eee4b62fd8513a489e9991fdfe5fa13f5048bc0eb46cafa3109c5208027d03cc14eaf824fcb4a852de867dda7af372f8d14c4d1702da00237f0af14d6d7eefe567153a9ac9fef247a310476b36b42f9e77f1ffef231b24e23e6c0a7ee33205e318348a462e5a9307549230bb2bb04676ec32569d1785e2c73b121b96ad5a2945f7a3556b4861cfac9d717b42c2c12b2fcb43d3917e642b7d3df7e157f0f02dfe3f772cb7ea1559d8b7c922601777072f42d4352833f343983d6536809e8f49306c75e5adb8b660c4d25055cb65477b20be2942697a0e7588ee1d1a0ba359669504ca922f0b5cae9eb765add61306488e3178e3f768046cdea0769374cccea314f59152729687b1cde0c091771359c05f4cab644ac9239b2a208e060e38b2a781b39b5b9671cf1d605e0a4de9fe265316fa9eece2dba3733b3a46017096d8c9b0946ddeb5fff6b10ad4e2b2f374ded397b51ef0be94be389ace61187f36e3becaab24363ebae2515f387c3dafe29e50e274fd14fe113d9dea2a951545910ea2e5ba4fee458b012fa311144a6e95d6a95320fe9bbf767ae76ebd416a61542abe5dbb760ecb12d65cd0860adc4a9e4308837c8e06c3972160110923252df177a0c4047722f54f140b73314b78a04a6464b99c4095d8473abe330b4ebc91bcae10070d9d5114cb4c1ff538c9d4bfb6d51aad4964083e6ff5fc12c738d2ad347fff5baafd71e781cb71a4d7137675548425bad0cf630151423d76f7ff80b27ee4576b1fb2f147324250899eb2acc008ddc0a3e17eef3f74a5360497441c602d2198db6ba86c5735c00a6a2aa7c67c3d71eeaa972d4ff8f17ca8d8c04cd4c73ad45b47abbf8a137b815941cae15f098ff5a0da5c62e48d57f0c6f1856b1ffbd70f6fee88289f7c20041e0c2e4213ff584d1b1ee7ea02201ee3949dda2c235a3dc672353e6d9c8c2472662d3ae41c533edf0df271edc635ce68374ed58802cda171ff41ab669919febbdd6d1b0b00d1a0ff621458b36cea1a9d0b89ff1d3eb4f44c50d20818e8e142fb5817dd69ec6fccfe4e4ad77ab677701c12d2b8f0e0c0b5381202aed6733064b0a152407828395f33616ce1bf94cc8d5b4e5241ee63b449746db6f4dea05fb84c68ba3cac5d187631af15fdbee1c4228a15523e49b8a7227c3e3ef5d93f1bc3d1556d31ab62c57dcd93228426623ce222f0148f8899098bd42ee491cd80d39beb9abbbf2d1b513eb11e043823a87f8b3c03297a85804d653fa1c973ad787f3776c3aa5f678881d72cb6685f40e5632cac0f0e70e470dc2ae7f7ef7bf3244f0ab9fe3a097a95ecf12b7cb84a3f8e53b0505b7887d34b1910e1894f2221fd7749e83fd7a8e16e3d7b28d500ef786c20d7710f4379bb29d7410d71d610db1b161c735f7b89aa5be46a1238bd8cb8574fd22cf6ab51d1bda4fce4c2ec77ddaf026877783a86e1af8d137bd1d62eeb3aa876fbe98739af95f8f5af3146d32a4368e8d1cfe6af9f0e7ca66c9be8f17d7efc69e79daf2dd2bd20f42e19f68f1b77057024b2425c1e83fe5f2358754692a86062a842f0e50f6cc319d210ea866775e2cbd91287d88e434ead30002bc733ec57167efac8d9288bfd1975ab11b4413b014fb2a2bc0e65179daa4800334c155411e699534743e19df35820c751cdaa7180d347c18490d712c7aafc6c701e2ccab78738e5904e65d4d20eeb966b89d14aa259180909f9864101b161cb1824f94fe693f83d1e70863e144aa48e5958145bdaf58394806fa417ef065cb3088c462052a8ed75d0ba0adda378c0f3bb4de94df1b9d93334210e959aea5f18b51bdffd28d4f775798fc3c6e44cd24d00126228ca523b244e9cb03359ff311cbf5bc396715f572d9de7b5390f39ec5ab24731b3e3044db95e41835283adc2457eddeac4ce065efb8be06954c37f7a93d2ce23493a0d6d1bb0fae798da321c2a84088279eaa4d83b63e804d8d5c44d05dec3549e26e42a4e51247fba7e69cff7c17b676162cd514fd849b4e359a73d30325bf7bc643a909c9fbf750ee3c9ccf259bc4c51c982cb14d16eaac5417ccf2379f445751fe75bf0d1841753233a537cebc72982249b50b5b7efb9375c99f7a27ecc4bde86ff3d12ee4015e956aa9a56e0df8de53c334c26628103f3976d71c69e0e71a45433621d742083cdda052f84de7c6c56be6c96bd7c8159b9adfbe2726552b6338e1b7ca4bdaf408820c27e01849ae47857544de56cddb872a103314fa7c6340f66382fd50088994a7c18564d8b39ed873988ecfb5a00e2ac23c264ccb36fd98358306cd14f6f3f2c64f0e5030f9c70752737eaa5edc707655496cdae9e5a6d105e6dd8d95a7091a4a3f8e78a9c4cbb682ee2c93b1003c60045c373090275c5807065bd19fe8794c04eed2a4003af7ecad1b1f7c58df6814eea844b49dcea15fede16029f74e006dd5f9a0b35757f2479ed6be78a08bfe1ed5bb6c2c814b9d7346ac9b04c4a0c0144364030488e8b939c8861b903f4536cc6d6aaa3392158e4ea7c6946e4e0ffc1e3ee30e80aff5fd0a6d3bc0f4a013ad91bef6d2afd55f009ba39d66669b8f1b9f31187cfebc4003cd5fbf9fb24e0840ef5a0e63f78bba75d2472429c8fdafba50422519e47d483dcf8cbfa41971785bbceeaf3af413852b192ff1543091481e07ea0fb71130245a5ef7ad1e68f3cb228392b63f1fcd7e8b51f146b113196ec8d4cb87c807a139d386245c7600ca8e3d16ce4e8436b5491fe7fdc75c57881eeca246092ae7d695da44d7c7219aede761a854d27d3fa4c8ef7b6996ad07b6505de583e46f7b8c802a1790da5f8b9c1353576243de9be2b215e7a8f21ea5a61ee5234710514cab29734403b1f87fa18d2c9850b6b944f2fb3c97cbbd80025fc3220fd7bc5823efa69c777251cafca80d95724cf7b0017571c07ceaba6f8e81a7749ee0e962c672a17edd109ba169ec83dbda6cca7a27aff009f3c0297425f3dbd2e7111e413d04abc09647987cdff61010505f744552b0adc7f3a448e4e5a822bdad2f7056629976a7f95fa79450231ff203453dffba6391551423e253b36ba97cbc5b585a6ba74ab0cf5839d22ae8c9ed3fab9ece005ef3d89cbc28b8a2751e29e0293fc9fc192a934e9155cd54230d2e3beb74ca5adbeb689dff8e3c6f8d5fe98a08d68a5b622a127664ad133814e1cea3bb328293d3b90b4edba75e5ca3720699a24f99249133b3f7f63ad56f15b0448a3101fa3ab1dc9bc30d16d273fba7e822e066d26cc76bc73dcbb6a853e4719574de11fea95f0c5e6b6c1f83ca6fba955fb5e4a0fc76634c9be00f3d48ad0cc531933bd78f0f303146a271fdb5ac4d23b8a42f142fe79f3a4e6a0f7d93fc3818decbf31d0d90a3a3253c38f21fc34ab1d8d4ca7882d16d12de6f282b87be372dc4898adfca915c93da56a75f656e2a4601928ed075ab2d330110f26692c64a95f433c0f5142a17bb42ea6a227b65aee2372682e168387946a8257497fc75167fdc49f6b87acf855cd23f07b378364487a388b451429f48b5b1b3f24ee462e5de5d880e8af08a5af18d8a16b6d2ca59e3a51cc95cce907d35292ad75286dc2c354cced9ec3f7b9bb7c754211b55b8de8ec2daf55afaa9a0130249ef1127e9f3d84902b6a6b8f488316bc7412a2595fdb59f4c2d45e985be4e5137634ea398a729ac8cc25f24edb59a18afebb72fb3e298e044f825fbe2c415df6b311d34205b7e412675b77783a10fa877f5f20f2c1bb0c11e27d62d4153b1adcd854666695a681d3b65691846e98752702151a83824f650cfe1f59cdf017c498197a2ca7a80bf4da7ddaf9a16b24a99a02d4e6ce6c42d9d35ad4dab67cbd73ceb24717a4d2b6389ff461b358a3f1d757e7112fe84ef482fa87880f1114b6512177ea5888f9ae6f6c29da525341d7e41ac8ff7ebd3f974c274eaa7360bd7f3f23c8f3b7db922563ebd5c55d4606935a565100cb3eaa56a3a9890c85fd6070fa18f14b3cb78b233626665b8158854e6f72e529199933ac47a16fb7ec3f21df712070157f35273ab97c486919ce1aef051f29ad8e69d81c517028fbc71dc4b4bd972aac2e56d6d4e72f7117e4597c77f3b4605d44726a7ef84ef14442dadf6e819f147c3898849bda2d9c9bafa84a9d493864ba837d3689f474b630bda92e42e8dc7780c8f17e9b71d0209508103ccb90221959d4781ba9b59b10cef33db91d1bfc9561968ed78722564c026b3de48de50673bc240f3fdd9c823239de774be2ad9c9fa2b4ac9a33a550f99571931bf3a0dab9dca30092c582da7fc6e88c863bc3a197838772b95ccaea9cf038ba9377eca3e3eacb17048195cfa34af721ca168849b59e0f8cc6618383dc902d83c28b8de64e4c7d5dbb0eab032ae2d821d989b2dd8a7ca7c5cd35374b2a3e3741e2ef66e75e0f08f5a1a3c0a18451a6d2897c568a0197dd4217bd720a0275dd909000690766b7ea3547cfa6966a1616cb96e21c93dad195290ab1caf1a792a3f413c0fe9144b0bde9f468280e55a9674a0b7b185ee868ddb82301fa360eb084339bd4cb1434fb70a0b370c607cf1145c9885498de73455d28b006f4e9478b06e26e81c863f4c813a0def31add5e5839540d9d8a52e6d3f1abec045ea395b90534512f37be5dbdf2dbb8295df9023c5b5366b0370b26cf60554981024efca73d3c4b76b71fdcde9a1b9c7a4b4d2d3918a1fd7bcfd1d76904a45eadae0fb6d8cf76a8c25b1d9172cba6037eba0e60582ace85f22502ad9ddc23ba175a0cb96c1fa7fda4d8c40bfefd92bc83582261c6494383441b65e5831efb87726f22d5bb81e82b81416f42579ec4a6d6b118688acbccaa314ddbf27d820a330d1ea6019028943bbd3d34e05e9fe323b3c55e1e0cc2aa28e7dfa2f521ef4ac34338dde1f07c186d35a7b8100f00ba3e25044e12a21476d7eced5a34d6f39f6a2fc120262b7c72a842333f7322542e52c9e3aa369bd1182e1e571ba95cb437477ec0d19391a772d93eeeb65aba60bc00a9b39a78fa374cc8b4c728c4b1fa38aea806f011523a8b24a693a0d57784e43d24df1132680b29b18cedbee06eb97149fb63f8b19cb9f94b57917ff8e769e614ff20f567852f99e5e2474961d4c80faa6b7454d3870826ae51f98c251aafbd2af79565fbb27ec747417399f3ff1d3341fffe88f8d6aade68a5f897ebc4d03140a991a00214004376c15cf616a1d62fbe3f6ee255d59f74eeeb9614e58d8d821c9f50c7b3043eb5ce8d09f4981ca23a0595f943d15a9120ce6ed5ee26803ff7d08bebb2045fb2ea2aa5410751cf3eceb7084d04fd17e41043f2626dcb063f8cc32f788cdb4106234ae5f3519e55af54210edf7ff1463d2f58ba1fbe37e087d230baa36b7eb303d019d76f1c88a678a51ffd7edbed8b7754ef9cf865866d00ce4dae9fd685ce6dd67b5a0db4ec37c2611815bd6f97867c8ece91fe2083bac9074822e09d70bce669b4862d65cb0eb5e6e58577db3d0702d24a515e8fc8693986718cb33a75c2e66541f117350efaddf4326886a1a5374768db79c342527d655fbc2bfce214d6bf1d13b271bb66f5c7212e0c4980f05f7d7cf22ddc848534f5f6606f857e8b0443e2e787fc448e0cbb08f5a12297055947aa448a29ed136edfa418c4492c4640ab96c61264f071b42febfbef00089a96173a24d64b56e492d36d5fdbdb6d0d46045a1957b130c6bdb90b4498ac475c0554c55b462fa8a7764f654c04034211ff446fc3c4855627764014cd3a8c1dd3a6affe7651ba65ba037c467f4a8dba10ddd089e79fe4efcb1171ae692dfb87252e1a275b926de9dfc470427c23fa92dee5069d1941487eb5cd62d89dbccc43d6b7f9de61de6a2d9d473bf45c090ca0f56c086e5611736eedb2ea617cce8bb4fdd0aa50f9e20ad9fb5db08303b31e9074e0818768cbe292021090700ca1dfbb71999443b0ef52a7e223660a6e73fdebd3c390c7100da2cce7da167f9ef9df5b4d206ef22dcbbbf3f238cf26cc8f988c3ff9903e58f164015963c8a2da5da96029e48e64c91a304e714d9959f62a549d42b8a667d5203a33a6b33529e96cdbfdd6302dca1645ac549861406842b565725e46f4e8256af495bf733963e824f78f12fad853048a1893276cb3f6ab08fa3787377672621285fa5c36f8be3225f882dd8620c1e35556dd040c19daa3837459be993df3764d1d7d4e4a97622e157cea9c8715c1f4ef663ce36b1c5ffeec22c01b803268fcf2468513c177102fb993b46970e2dbc2c95de1761e9b277dcc8232625e4b06c8bcd11a66c2b3d57cf6971812813e42832057c740aae192a587cb34f7e6211bc3caeaa75a110b8e4bb71a0617712baf1d125bdbd139283fceb6e3c6b061c413428bbd7d67b200909ffc011551cae85e61f95d9c17f6797800791eda1fb56f117133892b76fcac26b607969047fadeadf1af3692a7ba02e2f9c577f21728e0493675876413e43e9d496901f9a434439ad4d21371e83440a2b2743244504de64ce40b04408cf8808d8fedaae41d8be0741a03cd76647bb22212cb25e3214276afcca4f9e7960781d8ff350044cbacd736d3a2472fcc9961fc08bcdb911b65793204f1c8b7416e493b315118869730106579d56a1bd606d9ec80f4659c76f958694b01add4dc7427d649679e9c0c68e65e3b4507290fba25cf290bac9a1565716f322b9435217617ba4547964eb2114abbd019efcd07c80d394a9e26a97bb1ebb2670db21d3ecc16ae0147ab48431b99d6646e5703779746d2d9e111f4a5e7dc7a7baec7931fdb7358232f9f04b40f2fd6102b0dca3a4b9f980436d9b2e487ac9b684109196d7c64ce29ddb03cb3202626123ddf8001a131f3495f4d4ae4a7b704f0dd89e0b39ebcdccb080d302fb11ffaa2361bdcdd16b6323692791fcb408a968bdec7aab2a487d0220ea523a4d28e2b367e4b9b6a12c614544807f3634614d722d5bb33797b958ee6f5f08e46919330e30ff8a88b742766c33fef7fa38995817d602884da5ee62be55a0afd721f822337a67a71d768fb2864d1e7addff13e053c55c809277ebb271fb161b007b30a7577759ed6e07b83e734250ef4e59df1731bfcb2c524eccfd8585673d71a3a9f0cb577acf84345d3909366e3f46f556cf9786c461a627a67a6706186a2390dc1969c297fd57edca3d890c6cb9bdb48b36faf8245fb5e781ccce14a26ca59044d4bd1b9e06660db1d40e3aad6e3cffcce3c7b7ecfe8908168cdab790c7d8830cbcc95f802349b1349e17e0df4baf1f426ff88907b165dbd2974723c850f2c2a030bbebaa9dcbfefdad8e3d63e3b88cc02941800cb18aeadc6694a3f47cd6fb479545bf728301d0155dcf6f89dcf313815d0919b2a46262a2ba6054925f1a644bb28bdc619296e4140d064b95fddabc1a26f3b877d6ab49228ed41f6b5268d585c23fa480bb150d8e8138738c2e04d4167e4f97d623cf1de87d7d12fbf7f5673de1376d328b0d402856b354d19e39ae818886932f5e6f3e30d53f8b94428e4470cb7343aa1cfe8a5363b87eb830e251347db970a291aacbe9533eb64fa7a78f0805fad3fb551172d49d4a54062a89e6687ff8e14572a0cb24583368369c950216051ff445b7b6d26fb344cd5df965cf23907c2f050713c0e57ad329a07cf21621064b7b0c686310a572a39060430095c5553e246c173478f807636fe27d155d0bd2439f93b281f57632cd451b2e2cc3317ab92124038e9666853fae893984430653bf09af6bee64a1e3c2608b76b815a695","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c8468bfdae736e04c92ec57ec57c68df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
