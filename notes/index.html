<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a71fdf117caa31910daf83b24c836139e54c86fdc92cda4385ddbb96708e28d1bfd1be6890db1bd2204d0a209c0b3d3fa8d0b0e532a1f9503e1aebfe508334dc9cb7f89e7108512ddf4f53fcc5301884f7a9342c8197287ff778409fc80244bd459661606c884d968c48ac6a917db7a4cd483aacde8c744221de78ee81d737d2c51a189b4a279bdc6699ada25f51240a6dfc445eacb178522289679e8eb988298c80e4c09cb1c742508fcf27ef26f094d2e79cb60dabcbeb03fcd9625aa8ee278896a485e2c3b8b15cb3e449f75241c7a5e04a3eff58d643c1d4772ea9c0eba693a38ad3f1f042b5f7faa964016d3990307bf1c2e204322fe89b803f98f6588d9cbcc29522ff50dd35bf3a330c81d14beea2ab54537a267317f3854b5ac5af48c49b2b59fe434930ce2e06c29b12ece297432899942f8af9030eb3b965308ae0d74abff06c292c4ad8ebc7cf3cfb4f74c966c6785c7c60d10faa8b4b96c448a96466efeb2dea927710b86c9751b7ac98363249f5b13413f475a1a8bd4550b2f3dd3207b56547cbd5a9adc0edd4e46b87f6696822d6c0a33f5f9967b53e453a9dad21657d62f25e0831e3fac92da0f14c0d343f25c65ed0641151d7c5e608d8cfd7f70e8c90af40bf76b81b20f4a66a0e4b2a54c35adf16082cb38ee734c80d84a42cef45ac36637893f0864edcaa3000e55c181bc6b9cba1237d45ec252b380c63f89786543674d43a13f76a5c8dac2211634b481f7c867769484b32e712c8b956a167894ce81b92140e38aad80db8c1950efc8896dd6cc4f5559bf5145c4d1380e12b2d748796c5cbf5583bfb4b003350130b6397f6420bbc3bec9a10dc7667828d5ac23a78edfe9758cb6dff9be947783a62d743fbfe49acc0e0ac85cc046a53091591d06f5edb16cfb14e33e64a24a29e038a7c58f30e6c2370a9c62b2870cc7320be3f8489e6482a42f4b14dd4087b6f143dcc618dc36b865cbc71f8b1e47a2fbdd343df5912f1011a66ef56ada4bfe31e9955d761398e057e1bf19e2d18790205c58d93ccca318a740205be589562703fda7c8019156862d35cc9ac9405dc7c78a45e651d8e454487f2aa8d73b6c2cf080aa1814bef15852d63177a775a716fc0b0a6553609fbeff06b85c9e3f2c6c5f856bef20ec3954a888f9f9f3a79e12d1098e0888d9856f86c2a6427f6343afd05bb4ff2da462a8e0c0ebeac93f00517efe80b771febdbdc9afca6ea3c5aaa12aef5748e8980c5e5f0d23042d37872750c1f8e05be63773413aed44ca75251acb0b17a6927aee8f51433e1f26aa2ffbce63a266700896b6144da9499c8f0ec455490c9ef57fbb4ceaef5c611c9b8766151b6e15ad4860dd1bfd6cd00e2033f356f674e5ec0908998f42fe91ebd18ea29ce9837703b44d085a6ce10823ca518d64aaaa20ff195f38ab361819573180c589baac901033c2a136d3f7cfbe115631ad5622e5d0caac997c1fdaba8569a3dd73746326cc9f1548bde656e4c8984bfb2ad6c29f3ccd52a3b064b200b113faaad338d8804e60a3860084ed41323970348201a59d213c278378f3cd148b81cd13d84df8350b1cc72f98f523c694ec5dbc544c3ff6a30836e6d849aa5225bc40a27ac9cfdd5e28bd0a14456a1a038f9754cd8691e6f1b438f572526c9042cf882ce620a4769d99188886a0617fd5ab647f992b0a3e959e0deb593704ae0a73f7f6ef1a15a70ea2ed10df23a6313762b83a39c2f6a4083fa0c2d8ae1335e7ecc47ea66154fc5630247ed8bdef00f40168f98b5958f026edd0bb15432bd1304efd0fd7b1ad95f879621a615842ac4e37379731089f9cdce77c5457ff415a457827fa3634fa8fd0d8edf144abdfdd9e8d7db0cf78182ebbff5a2e5d3658430ba162273975e2db9c44e1ca94234ae26795d2c8c6ae0c13f0d5fb1659c026eaad54c2395974a677898ea804773c4383410c0cb0ef12215cf2e39fef0a845f27eea6d6d257dd225dd8838dbd1ebc27ab1ef1a3ef9012f9ef8c96c410b9cf566fb63b86466ab20fc8064b00a82ab1a3e38a790da822d6756d2ddc54a73b31ef12a7b5144cb5daf2a9da4a5764bf487dc0cc453f73a38179c88872fa597e8fc89d6b964d74482e055b345e7d355aa683190455b2c7a95a9c69bbf48459f27cb980655c8339c3b66bfbfa243f5b61f0335e7c2722c1f5826b87357ec151d7e57c6101b4c2a1f026c7e497f0d02b7c4e2f316a145f41cace07a4f99c28c29d8d968ff764ef617e0a5d7246208d9be54a13b649c520226075409c7574debee1d06dddcacb8f3e441555a1ff984790cda348fd3d90d6b008a25d04c5e6e49c85217ff34acd53dc0c203c99a6001fee6b8106bd3f83a3fcdda545df9a0a2df26656aa1e1940dc6cb8a00dd56f3657ac9c9a64ae8e0c559eb61b5aac606d27775abb01eaadfa80d89464a9cb0ff64d45532c5262e53a2be24bee54ec8a3c9ad17668a30b3a1eceb10db7ba0bb9a84fc1d947face574b79ef03c12a30eedcad86d312baecf676fd6ab7fec7bc4f5bc864e7cab913172db36a6883058f33cf50c782d7e8f1a49c1e02d9c9b642fa17b75fe9e6631cce31b57fac6e053dd87fd40442eebbd0e68d53df87c5374b8e2b60aed984cbec917d751fca2d65efdfad5c69c2630f5b5dec5d241be7318bcf571d9871c4b85287c35cc61dc8e5f06c72d0e1e87c05892a4489ee1b2fce6985398168d64385e103d5992c322a08792d16bf788df60dad3df820da2201f5725c294d4396dc299311fa480bae5d78511c13aa6fdce644e3d4b75e0a794d41a7fdcb6fdc1c813c31efd66d0198a5cb598ade1c151ac55a39653af78d70e747f90761f5ece1f3a0a586ef6119bbec75b11f362af1e550a2558fc7156e8171b47162d7f6f6f34fbf6fc39706b500c04592d529d9674c1e54f694cdb9f51fd5a9880586f01e23e0cade1bee4d22b538e6b999dbe2660f1fe3c6b652a2dd076e61fd9cf00bfec8654b0635790f7cee73102838f0c5e87c30dbc52e449a33da27d65ffbe71b98b507a467556e2eb0fa9fa9f7d08ba51ca7e54064b637d0d964107c77467d72db14b10b44cd732d892aff9e51b845842ef850df3bfe36ef57f3ef0e94c01cda6e50a855b99cc923e29abe3478490748b70569cb91e34a2728de7338b6381f35561d4861555f8834d38ab9f4ede6eb8f3779e096651d203850ee009f5921541783911047a2d5cc31f9666ef2605895a89c23c56aa4a84fc1562864d6f1c25654f341d2c158565e050803e0dae9b43e0104c99952daa22649015b1cda5c28a61f71fd1c750a85eb0bc124bdcf9df936baf3808f8a7c0d77a8fb63decc8643a9f386166433eb6a542beffa01fb5fc59a14444f6521a17fd05cd34463e85dc7bf5404a874cbbee1a63f55dc9228e63e3b55e5c414cb44c405a442000b9a451193679f032cc8f39f6a988cea5d302b8ccb00671b51575bbbd52c9aa4999e6501e43530fd00ed4fd475e105a66e5ebe2bb9a6e048e502136e6d06d58bfbcf941cd39f6c76aa20559b43ef46ae1377de41d31b6bae8392d88785873d498775d194839884c9a18c504d3bc913bc2f66ba4aea564480ed79fd84e83f873767e51709034ac957cb43b57e1d9f62a3ac6338e2becf064582a97b8ef696dca4887f85e151c7501732997bfef8c8fe8f8226e734bbb31f8910e94ad911aaa7a15d1177dfe1fda786ebebe5da15ac086dadf239693a0119cb87207b63dab2708ed28716d84724dab30ce573897d225e8ccc7d4e741ff7d653476e1cca1acf238693e37c975310726effafd16779b9f23a979beb7533c283dcc4d2bb304c66225cfb7fe3f8766aa70692ca2280965450c2c3c234c97130f758de1523e9fff494f5759991fe7adea6cf256f7cea968e930b089aed2dfc86e1cb9e3e1131b1159b6715fb6b41cb38ea6b4b84807b44442cd11b7e52ba88ca8a2c53706110f25afe87cd8b72cf67bce0e36312f6ecf0974e601500d46d22c359080529800b52d086a93d8014e0a1a1283fcd510646292228d45159e875db723eeb053accbe83afc50d71228b85e07a919226645dd520e6d23d5b7d146c8cd527946eedc494416e7c67f20412a5e3306c707d60ae8d5a3b6faef49a73a443ca5bfe76d91777e6adabb4325ae95e58c984af70b690831382f7fe8f40c4a8e23dfe31ae8fc55622e8da2c0ed066fa46b932a8c5988bd85894b4b3580c53a79571151c8c59ec285958a04d8ff0957f2e42e091669c78e01be3be3c67ccbcb08d289f298af713c1620958678812c3399bc6641a9585f374b3280d6c60a0f3592da05ae6a0a2ef8efb9d1b5778d779cc7ea4a739a23fd7a9f6640ae54aa65f12fd2d4866275c5042bf3c360f75daa138a19e0f3c5cca84316d66dd66a238002031fa80285fd2a43e23e452b8e363a074e25c80682eb9674c63887a2372620196c906db20c691087ece0688dffe7aa17ceb5cc27e638e56190dc0f67bb4803486d757a35c47f78d04cf73a5abb884d8d959c54443c6c4a58c55ae495ebca35c8e322e45dbfc554101c6295267428bd2e4e9065fa6c452b56a15a84aae8c344ec3d110f9861d91394cd587c2b9ff03fa7694808467aada937e182fa556a4d4f090b1b1179a7fd76756615dbe073073edf33706ea59fe2a2c0cbe1baac91204279b4314bf15d1e656530021fe31f3b9f5bdc5ad9db215d2cd72b13fbeccb58e16d8f8405de4a35c998fd029a22932b0d05cce535e422ff51a21c3ed6432c7d9adff6082a687bf5c3ffbf8980a05e6b5397e055f67386e3db664605d9ee8316525f3821cf5aabd50dfeaa5da5d664e37a4a3efadd8ae20fe0243f2dd93d03e2e59f686d0de59fd0fd7c34125f67b80de538872a5cd21426fb8afb18d30a83dd36ba1160c49730e7d02d708e0d07754c3072a0463aef3e53cf2668c30bb5ad63f9af1c27b5e34c2b5311c2c72a34bd2079c4734c7872e012699e07a92e00e5846a540914c2c4b37ebeaaef12b1996baf93a9c1419a28e22523bc88504d8e5ea8d1680a34d45cb7369a7053b3f15e485eca1da1098d2174372ef3665e07eb5811ae69bc03ce19daeecc15f848c8494ff652c7f33aafc9bdfd21cfe373ea07f8b323b6f6e5cf78031d0b7b34489def560a6d403de41e50a852ab06adcb3975dfc099da20f574e5ba2a17d6e4b7c29f240802d750db303672743ed89ec42e40892b17b36104ac6ea24ec831a5dca5960dec194b9f6edec8c928aee0c82aecea1560a9a57b0965a08cea254938049aebadfec847e977a5c77ab9a4d69bff2c4b9f22490e426c2a1cfea5b1add863e786a9dd197739b0959ae99077c9310dfe0a6225a85a91c573e7096296facfd68051f577217996403aeea5f268a1bd22eeb86a3725523e37d2fdbde99d758327140bd1a07263f72c55c8f1c86356e517172cbfa51b019b09ac189bacaa010d8c7736ea671952cdd4cc1e7371cd53d4eb836fcc3f2e13061b8e0d873f04b6f1316b91af0ea74061917911bade116e8c7ff72a895b10035b27670b2fe6556f14ed783fe9be8c7b5d05d74062712e88f66102644b06e0d6e0775c9a14ad3f0b2a0f6c6f145bb23586cb069e5817d80531f80fbf71d12d51763ba6f2ed2a83ed6a871e90b6e5ec5a4450d1e96025944f8fdb99a846787bcf8b64fee19a35f968885c853dbac691cbf7f8df0d2d3e2f22e73332f152a4657943af542e76202f70b0bb0218f4387d279029bea1124bfd1798973b5fd8f42f3f4afb64ad11ec7de1c974085d284debc634fb95c9b0570408de7e1c511e5df83ea8173257885d791a521ff3915879205829b42ced3c7951d8fde24148bdb929f652ff82e50967779b694ab9e7c71e4348738953b6bc80b4946fa936cc557af85c185352cb381fee6ec06333920a02f35a285dad4fba353892ec3930d2075c5a740b036175b78b08c0b27c4dac0c89f977d6f0b538eb860766b2dcfd8a50f48270019b0fe3a61b50796131e918d2c019b9f02c0d22d47a9e377184c4bba356d8c7501c59bd370c1c0beaa32d68ce728b3a99b27c3a4007dd125e590835f5b5a959f113b7fa99c8b5eab602b2f83cf3e4ba6b94d879d47243301bbefa61ac5947604df4be1c2019ca70df0f98587692a79f979aade93eb2a343e70f5b81538ff46271b2d0cb0e976994bdbe287f103f69b9a5fa25a53e54ad35c8b106a01cb7e406ceba76ccc46045da11e06742fcca21dc8435aeae0c6e71a488aebad20dbbc86cf6aa57edf0b4c50f236e9cab8566b3bbb5061fe0445ac5b9a76f10f7312828a7ace1e7659ea88f0b1cc8b7d90d97446c05cbe982db93fcf7b8adf501c8c26e84b68a5a15bd62181ff897ea55fff5cc7d39000a3b06c7f33601cf4e5081c7b8b72ce86722a3913b7856ea61065ef27e72678fd17d407c623fd71094c7b7ef6c7577ab6050f4f189cd79d0f1835707f1c5d08c463b7f4f4af2c5d77ac1ba54309fa8c8fcf93cade834846926820aeec72399059d080c436400925e13fc0df76b217c8299a3c06e70f76849bbcd884ae4adf75eeec07d4577c72a413b26b0657471752209d12854b8069e942e6b94dc2a3f64b4fc6fab6b806259f86fce51f12a578479c68dacfad0357d90582d92da7e560ee0062fda53a6d632c9138a596eac64f14d1685e5e6608e263e8452d50bcfc9e46a74ffba0d979972c3599d754602cec3d747ce7961a8877dafb4853eab6f2609cf1a6c80a5c6f0d24359dcd3be6a294c6a938947c3e7c8c8636d913fda249649b251757eaa6119540eb979789f64c6abd537fb073f1fac1c23fe0a4e93d6c2c4ac855f2cd433b81d2b06119d837925c1c4423fd1d51175017ebeb2fabc6601f83699332c152b6e1111e04d1764446e9c62cc4619b95fe85554e78330bd2cabfbb13ba739aeabc0dc2d6739e29b2ca6f186e0f657aa8f951a6955ff757a7b1dcae786d6d7ea96b625f724b21c02461d4fdc18b9b8061556d452c136616a6a4a111e31f0f6194c96fe074f4708f6fbf02346c1373fc41870755a5718d7dd74fd32d801cd0617e0c2d4056f1c99859f0ab264faf963576d92e27c177dadbac06e03ac1cfe0f7ec647b3adc649034e1ad400af675f83f4c41e3485022cad832dd0199d979aaeae2970f9e41ae4419c98c320429ce9460905aebb93ceffc37bb45ddcf555aad73bf3187936a6fa31b09b0fab79742f62dcf1e630c059b0bc92e42ae2606058fe505135e7314b31ef64a07a4e730395f73edcc9794ef359b1201a1ba25fe5b793fcc7ae26c78efff4d1f03fe06da3cd1410a268af2b765e9332bcafe5427c559b46f2e71ec82e3cfc2948ad0b28fa9201bc5938485f96008d1f963369f31909e3a25ff9e32f56e96e0c1058a00707354cff3934a565ca9e14d5a6919278fc8e966eebea01cacec8d004c19245cb1fc9538ebc639efb31c5cd836cf9800b6ea1f05df3491c3da93b244f375b2cdb75f0e6451f679393e53bd5fce9d4204b261e64bd79349912e68ce24566420ce36e771674354efa9ec9773d1024bcd73cccc66f7e0c33e9d6039c47d03d33bcf0e6d62ab745b2a092f32d431bdf313755bcdf2a0e4f8dac8c43f3e3b7168fe5e9a72ef3fc78894245861e1d0568c9badfa6063e53435d33baa6ebea61ff8d8d3f6a207c06d796e681dd68695544942bd7d3471d439a2422f0f675e3a22541661b675cff95a5bad1089d3a3f117979d1e764d82e8a02504c1c92336aceec1550d78d66294baeb3fadba3e51c52d8ce6dbc0f7543ddab3d8d9c9a08b22832b233e33f9102fdb193f207bcf78c92471c95a2138bd68cedad03132eec652cae944e50985bd2ed168cd465ba63b29b5e96248ccb8a276aa954c86bd676d32f22a9e7b763b518b193f6a321c8e6069ce2e0309bf57d817bd56c3525842da5b4cdf9fe314f712d73f74cbc1cb6079b29bd42a8b4f1511a1a7a52415e0b6979ca3f696edafc3578ed6e91b2ec8b466b7f109ce1550fe494e4e2c3ae7fd0406f416a76441ff603e167b87bc0f0d6645837398fa20340af74ec76a4bc1d9a55f88e6c2622375df9e3d898abbf0fe8273d5ed350b569df2d75f793742f56b2213e251b0512b08262091627fa775fd01431c7b87095d78f958585cf3dd808bcd2d8d9f1563e3904327def655e385bc716fd8b00af47f550ec9bbe955d4aaff50448e11751e9a01d7092678d9515b0ff696c4bb2127ef9dbdebe5ca09986b8793b0a11076063b772a7e662444423dcf3b65e3e7c89443a15459b6121e1309db5fa22d0e2e0d3580db275cc10a957f4cf4c99353a88c8e0dbd9cab79d2cc35d50b1db6b42860af3dd448c9dc3e016befd93000ef942508cf999c5512241e63e0b5749499aaaff405e46f83e9f30d5b42cdf38bffbf4a8768e333aea554aa47236cca0790280fe34c4a21fb201ec307a8bb009348ab78cf328c58b0e89a01bddbcc06de54a2f29a08f3a9d67a5bde4b8f9bfc05c3368082a88c5baea789377ec768fb3141b878be7035489f0340b832834d08936c67a208f925fd94d1aa7c3cf302b7aee622fd51bedca87edc01f92ada27a3df28116a9a3f9179b63cc3ab0b294b39b0d1d94c522b550d900bfaf98f5eb3f89d2b2cd32b374f30253b9e788fcbccf34cda28b433296d71d51476dabd1d7c7296331ac5d14f4b3b79aaa762aba757f6be529b99914e69a85855e04b8519825b976a7c32c4bbcea8fc9162562496d23a09b01a0fa8d593508915d6c29ca65912d21166f98052a5d39df2d7d287f67f26a8168e734dfc0df68b850a567cb62bb0b6ce4a793f1d58e10855dae0f6f2f807a62ea64f84e7528a22dbac3e34d2a4a98b4f9828e4c3081aa6737d24819c486a42fb1b3b09717ed07358c3209104eb9ab573aa753bfb3575a395144f1c40e9408ab285db13d34d0caf648e9ddb723ddac979e8fa58afe322e69865e0847cc69a16269aac2168bdc54bcd1264842d7ee1cb47e4ac21d0d5046a13773d3781d683be7cc08ca99694e002b012b5cbd86c48655cc17633cf8c55df3156f97d7d76071fd2327003badf923fde2a86c7cdae2443c110f3ad6e10b7245a64b7a3a282410d37124b98a429851e3a05e260c330c45f5bb32145b2fe692f308a2351a05a02067f50501bb8d3ac2a3f99c26b30608bc738825b138a7ad5c896346c717a95ab8f18c8c7b36c5a8c8f104fdfd65a08f05cbbcdb4ce9489cca60311c61e93bf6ce0b36723625a6321a7587fd2bd79ec9e42b4d89e4a1bfbd19529e053af8610e4764465aa57e75ce7e5f4c2681bb79b598307f2d4ee6606169daa7e76aaa53a42b5ea32f4a296be3796c8efbdfa894be7388723774cc49f8ef5435c78b22792954dddc4a9da301f7a2ca65225018ad2825c3cb2ebea7bc8581e0b947ac32e1a422b6b7b10cb6a975d2b7e42802cd4b969138adebfe8f9f9256cdd5d912598ab85e7d3b03338e67ca8d95ea4200310c6102127ed099616332aeb57a07c2c27a01ba49e9f149cb4769ee1e1092e35c666dc379b14897bcf7543ab18d739117c92f5aa53c4603904eb942810e9f99ba92264797a4eb9a52b700c6d5cf0ffa77b3b09eb14077a4e936329af7667d67da5b796b4555e51c7a2d8995e0a92f67fe25c41c8cf4e49a3df6cb92d252b54c8cd4d34d8ca8f5edfac9eb970a789d1af6453f2f77047b9f77d1aa1a514a1c4f4eb560c4f1e7f1c14b28696d7358146039f52d30aa588e6a949c0bc868b1cfcb5389337ff47df847a88f9979d64d6e0e6d4a2c356db5edc644f9a66c2ff768fe695f4a6813e5e3bc6abe874a855e182800675c62a5cb367d63a8af02953ca236427ec6cba4ec74edd8a3be3284e9a798fe8a5313d5e9ac469aaf369d648f5e4bee5988a2bbaeb5c1c801057735bfb283e5271cd3b79f6425e5ee820bbeac4373d736ae7877c3574ed872deed44156a9c047accb108f0a52fbc2f34fbfc982d60b8d27c4930186282d9d2f1ec62140024a0c5a277b45e132040f90867ff644fce57bcb5bec6320fc692da7646df3ee4f6009825915539624f6319572136b666dea17a61f822d258525b9d397eb9b082ebd3b3104edb9f69c81a2d149ebaa164d7dca2e54939a1488bf66a7ccffb775ad5a03d6c2d10370b7d11b5407a79e12f058b90b3601d5cc32ccc4eee1bf2154115dc208a55b567f279402354072fc7934fdb990beddf632be03e1d3e26141925b31ab8269ea2a088839b0e089cd7953bd713a902de70b995895fcf2df93c30a11661863d8f1acb60a29ea232e4316b99f28c73fc6a301cf4986ae2d6e9a4f92fba2d250b7a5383007e4f49ed854c3bec1d2a2274647b62cc619dfae104f920043b65e73fe7a43c7721af64e2fa4e7dded0868470e16714f984881e2da3dcd3e6cc9236377033e8dcd46e900c626611bf14a5359534589ea1b840ad9e1961be74eed89eb6932495af6f656b119204424c202785c9ce869dfb6a14fe39028d176eb3de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c8468bfdae736e04c92ec57ec57c68df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
