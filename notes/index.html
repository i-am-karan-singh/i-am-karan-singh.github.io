<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79bbdec035f88363d2efe31553f0a62e99668baeb68454bab3d2c5f2e0b6414e639b042084f3433904287cdb97007371f979c7f59f31a0d31e09d5ed68ba9f35318c695f2f107560f52f12db6e6ac12ef48ad989112f098672fedffa84d7cfc297d5d1e994e2d8bd74ddf259538a16c5a4d2552f89d52f115c5544adad0375b091640ea5de1dcf715abc42bd67342d0707ac9696b6d2bca9b722bc98f1b3badc7c657f6d4020d82c97ea572e22a6c7ca9be1004bf28088d8d50ba625cd5fb12b07fd6a7f416cccffec4e102c2095d74ee6f514d120edbf9acc7e60067d4b0acb22376da297da5009ae7c5470465b63d970d325e020f04b5319735c272298fc32c15116ed9c301698fd88907afd5fd9751d19b29aa2cd9877b53303c10631e9cf227b5523cbca369c13c80c5412556d8d9a8630b197f76442eae7b9c12656d55c9e942f9667bb0f6dda536d361e3507af59fd06c9a0256218aceba44a4a0481cba40cd1ecd6e968bde4dae5de526f5ef8991790e06be63a92db76d43738fd91b0a9afa3d238711d592a97560a6e2a4d6c7f4f54e0a9e210e3cf34a6166c28fd6b0236ae05f140114e2f17c7648cef7f86263123a5ca4c798d366402aea8f24c9151552db0fa8a4cbff06fc684cf37d3df939f3dfbb105ae8d7954308771b91b63c943d08cc8b547f29d37aab527d3e0f9b83a457eae8248d7aeec986cabe475df9c7ee711e01948b668c8018b9218e9db17f4cc98d0756d45c51cd61179838c9a6131ec7ef3c8aabaf941ccd5f715eb20183ef446d4261602d87229b9b9582aa74a8c6b4ccd5078357914655630746b8cb8c6a4c0d6daeb7d9cdaa4350b2183f4b6ef97c250aa34aa8a9d42e1b0af29cf3d7435440cc218a911547133aa3134f2e043f8ea035db282ac9ab1cb9855410ecf961eb28ff81167fa97c2741a391a124fcaed210b806dcaaa49184849e2c72d02c4e87b688758fcb1880062ea303e4a994b90d9abcfa13eb050d14496c30e6e8931ce90919bd77c20981abd23355a5f392006786c8a5d9abab67e4d8dcc5e24eed6b8f59d0b509c764f27671b4f76863535e31d46b433b842a153eef468eb34bb4d48b71979779b2ec5cddbf06740a2426fc32dc3a8d86e47bc2102e0bf16bb300122767546503d78d3a0206063b2ad4c34129071b912968c6b5b560ca0e95658d34a87abc39bd2ec7ee493d2edc4382fd4e05ef8de2a90c81588713038d264e88b2b4690af469b29c2172301a8475ff1160c4ad3570485597840e76e96659da044b0d8b2e970a07a71c261fc374b56f075ee0ea636ac10174852a89af1698828336e2affadc32b4968f536fb01038779f358e3b803af3ef44f9ab4900580d54b7df4cf139018111f131d55a3686ccc00826235c80f38762c6a1ca6fbbc9e16ff80f22213c7621b0659b60a6c6bf12ac3cd929ae9ed5434867676b24646abe6d27bd4d57ed4b95c2641024d688f874e38a47cd1130b58af28583bd6c957729f4214fea7e78d0b766a5d37aafb965b548d27ff1e7f9a8937e042f268da6de6d6586284f53964597b4ad4dade1c4100948cd7b0b9e3131e4d18db04062ca3b36028d81cc99b42339cf6a9904efa59ec56e2303cdaf5090883df020424301bf59c8c716083e16e2147604adbb6a8142a848f6d4765c3b0c49d09f6ea5f39283f43b4805eb36aab0e17126dd5f1076407996b1de21e552bb2b2c78e476fa1ead03a5ff58716b693836188752c608a5158739f4269b9e439c2120ccfd22411ae90a1d5f8197278811ae45ebeb925c0d337553b14b23dd7d620636e1e8f2a95be970d6a788cb97f397eca62f08035f58f1558a8719613a2204f07c55035f93bada861107b135fb5efd2801d4f4244f081d56b04a49c73cba622867a33c04abf803e405919429aa933b539a2f8335d5966ed6ea28472f936a12645ec1ab0a8891353b32bdcd82071512c627203ae80138ca8d6674233ab67d8a641854612fb4ea94ea7bd26a67aceeee5c24382e51ae0169655009da2428e4b83efce6b5969951423d2d4e34f4a20065b1e2c6950797195a5629f133ee782044f236c5feb0a6ac6d0e1e81c23a1457f377f237dc0f008e93e84b4046c480eebbab75ae2171b6ee5271bde262529dcc2f8bccca0452bd9e578e3f6a09ed1804d5d5407602d130ac2a68a9e7871283a2a98db867eb3a73a0f849c2292749aa151447977cbf0be6c22e2b8791f80d750336bcaf8a4c2d001d2c803c29a7c0aef47a0ff057d124aacdfdfec78dd1bfa1652f6fb669a78ed2e401ee1122455065fd2e50bd3067c576a1a30a7d389d29e1175efe63bb72aff40b886f53648ec90a8faec89657979fe9ae020385fc60e2c8628dcba15cbf83ad05f2b850aea0a851a6b94cd2aec27e01487cee0353b4a9c7a084169bd730509b79aa4c0b80ac1626ff2cf6475b5d715a713c171348725afa956d7471c65da32558eb4a1344991e79fb33d2fca8c96b8b6acf444c28828ce460a05fd9bfc59c6a4c733b8cd294d6b8c539b1dafcb84386bb1ef23aa0ed7d3330e0479bba508bc6d486d418499b07ec0784036e8c529beb04ee979dee88f46016b422ffa205ce932b41df1c74518cb0609cddbd30a5128033501ede5f7a9203a937a904b1c0ddf225cf595fd02b818ff630911c2bb258426645c62bc7c758d85aa6d5375881534e0165040ca3eb563dedc32183c942b106d3e2ccfe5df8526ec904b4d5db1eeb2c05089d3bfc257f197270b28ed6eb9bd73a4f2e04970c0659a43ba6f23db4022866e5bf72b3f5afea751565f6808db34ef94e2eb809fb7b18c9d8a9cee5be1eb02e81075e6078c3216e86bbfd5adb728beac93f75b1f753ffaec2e0ced7239e618c956a7fb64ba1d87499f0bdddcfa8e04a4f7c4ab208e33448c1276645e8baea8670fdddc5f36a9b1de299e5f078082f127280a6c9039e8348dccdf70c753f445a28a0883faba6cee9d61fd048f02e5bfbd6de8725e8d113f9ae8fff8ea1cee446526126d040ce20bf59d7444d8a01ae6d2acea9e6b9b2d392e4632b25f6d1137b0298d60ec1528ba29cdb62e171672e6363502a673dd1fc92563059324bfb0b24400ed2b9e8250a8ea4867b126b9a3ef582cdc4a73e83addfcabb02dea15889c2e34d5ba414ea27ab181b894a1ba21f0fd39c2e0176f88e60ab6d01da66ac1b80b5b6be93fe6126a5887b34227f5396e896dc7668c647271e45af9375644f77a7836bf914877611714768ad84042a33a33044006481315dc138aad8786b358a25c47beae7e878182aa5d329005d3e845dba1ec9d32242e1f448dd5f346a341d9fa7b378c5f910b2ab37a1837c61b2c20a7315564f79bcfc59022245e8a8beda4841ec4dace615960b5529aff55489c95da5a80bc6668d6f4511eb675282240b61ad08715f13cd2b274f502caf8902b79339126ec4ff6f9ec3709b34fa19d786c90da5a3f97d15b19b3ef5495a192c4558ba750709862fa8c0345a0b2b9a886969af7480ed7c7fbe7c2e17a9f0bfaf8cd67eeb035c71bcd4b729100ae109193db5156dfab85254706fe65a5b05d752061e103d2563911f83973ba60477e8d9a502ea6890f90dede260834e6e034db1aa53d5041a4b617835fa9df1e723e6b4be8c8fd9e8b82dac00f4e73dcb50a54fcb2cbe7ca661d755752a1ab32db5b7dd539fcd5e444ac7e91c975356438b115d30cf142ce9671097013ff2c7f0c80173dbf1aca26a5ba7be68fffa65bd0e342c7fe0cc2edbc842a68cf6727faf210dc00fb502db1bbf9364f6c9cf4a31c70249ef3e8fbf8eb6a292cd0abaa08ee70f7dcf6f312110483d9a71ae507ef847acb600563bc4a6ed6f6f63ebd10dcd487d1bfcb6680a9412fa2687cfe6a2619c893999c32f6a59f7c3bcf185439489fabe56db273b4594a679047786069ac62b9bc03d8706d994e83165bd037440f6021c5d35521523a4f14835f3165e54b829ff817866412b2f8a63806b17bf7df87b22ed4464fe5bd4800c12dba3bc667378d4e5529cd742c4f2dc6c26440237a8841c926cdbec2ad55ee2d2ff771235b5dd00239e994ba3aa4b0cce547fc89ad0c2672d2718be65a72214a40d07d15b04d2df0c3e9d191da871017dbf1c655aff9f421f0270b245cd5cb5cb312d421c5215ee226d07e69ccc429b4503f775449f77b385d99c9a5f5b2439e93d7082fcde8dc5d87d0b34bbdc4e2ae2b505833500ec92d6e6584b2fab0991876fc59e4d7da1bb1ed0c4d011beaa9dd39c49e4e0a0656aa05ed68cc94753f7926e2bef89a2d42edb73176f1ccfc33de6f32b796f0a2ac8c9a2dab6f116c957803ea3ed3ec89f0ec8f1b2669b4ec2c1f4a19a39b8da58e2049e8f410f81289cf012bd3820c8e72bf8b0397041521ef669c25a4ba89922e1a264cb013b8d265c26d15cebc781aed11d2c8522817367049e63b4632724aa7ca061817e8aae1f6d86c3f815067b2794964333b793a983a6656f20ea7133776ebc7238a984cb7580bbffedd928e56bb2e1d54b2d2b12fbaae4f5fab2d10d3b902265ec6d7f82f2ea878e48515088d41da099404a128eb713edd5e061171db3fb94999a4a21dfba1116829af7d1106e1a94d523f8007052e1d4fce06a4239cf16f0877ab513ef2eed7588d73c5d756abb386b2fe2009f5a3aa4ebca7dfa02d9875a3abe40f636c7b674d71311df7b69fee0e7763fc12c648390ee0c129ce2434b07edfe06f209b815b083bd13b89acd07d11d123c9cab5fdf7e5a739ce0968775e697d842a14e6a4e976b564f792e8954d25beab649ef1b142087b1910bf09ac3a1df4d2104cb3c989b0e3fa112c871a065f38044a9927a2b430bf4852422da7277142edbc22fce773b58abc2e9cfb8d606ddb9f3f1242f9d520fbd1e376d53db56bf0a3c10d9488dd69f5abee3dd483cb22532b65dcf64ca6b7aba2381fac2a1bb2dce58e5b0dd8ca8e188f62c9c059130cdfc1a1e56b61f1215565860fb89508070f37886a78a17c5b05e2418b87d1017cf2ca6fddcebe00989817a926c137911bf36bd97541ad98b224cd8874bd583027d685e7bf50c52d5bdb8fb2af35dbc9d024d0e957150c238eb1f018876e9bfe0b82f66bf1bd2815f9b44b608e7e396188ce288934a286ea16469392f1b6a3cf431aa86842ffea58d9fc85b19db0556a135c7ebfd878cce7fca9c63d9dff15f50f397d765dc57b9b08521fe057d16da65b21b406b280ff3cdc8d53b5e4d4cc18829bb247b92b863a5cdfbe5dea4a2c86d3db39f467d4372493da9e25cefb9c51163aaf06cd794f98511e6d85b953d0b5d98b3d8fea84af8025e40c44f03999ab287abc5f4d15f007b8a3acf7816ba5d5e188c214dd08efff30f182af98c9909fbe97982d89b3e60f75a37fd99628136538d5d8555d434c07953bc0610aab88f5f98e1005f8e6ab5939472419b7a9b38232b37b88a93dbbaad3aace19316cbf0c91000cd4e63810e0f4efb754fa35e6168cb967c07e20974147b6f9de8d67db38be866932fb518c28bee8e77d22ac8941a6335361fbddfbe4e451da6ceddf9b5336fdf28e00a7b9e54ec4f9af72e148cfaea3e68545d18ce548d9f41abdb9ed593fc86f871109d0b333c36f72491a795c74f4d3d3fd3383ff5549c0c7eba2809e5879d3bbd9c7e0acad82377afafe5c87a7968c4ea26ae7d3885250fb155811ad0475b2a3ba0a6e5029d3130aefb11e4db690df1dcdd3fb386a0b04eaea45cc29ff9d378b527dfb06a66b4848326b1fc19881bc89de9cb380af8047146c6ec940032fa6b4cf841478b693baff3b14b6cd5c66c0bbeb4bb3356737c828d2e4210965a931e57a87893aeeb75742e06beaf6a87c11fa7d4b95828813794a2cb3197f8a382b264c6fc4bce56a7d9c4fbba85751bf92b12af3a62f1fc5f482a84739fd739c742d9399d73cda033e54020f0067bace44d57df430fd530421c88c10d005fadf5a332af17fb9a7530e9ffb22a13f6e410f14a4f904224dea12a9cd7fe581030d17fb2c27ec0e49fa976af28687ca18bdbff0e870b5b2d75a5ad321a1d4bd772580aefd65063c56fe5212de968ea1b36a4370d0bf3135b111f01f3022246856b14964172c31f84fefcec34f5515bcae0c5d253247e8eb70ad1dcbf9995a026679b0cd6ce6be8a365698af73050a5f96f03cf76ab5a6625e6c0ef5a18dad9c7fea8e30def3f52c6e159fc40b063d3acd7f7b0dd864e7a97ec53c8879bb33fc671a09e7eb1f6507261f2472554c18ca4f127585f30c3b9dee8de5408cba76750e279d2aac9d09663781a6a0b5554cfd77fca69fd52d7af809b1056fb3d4896cd270a298c67bcc91f4098ff1bf294cdf51eed9189862497ee076f26f2299b87db89e4835ee82c7bb4aaa0dac75e4672a3aa4f6b2ab105e607cb3c5e243182754c224b0cbd2885decee9dfcffb5e035b5b4f338259a52021a196f79f91db8e66bf3d71f277733316d26a0309ce89a790eaa3ac5893566a2192c01f2c4fdd9a54346350063b8fd9a11a13aaf5e01e30abd9f52eedc2f1cf2757bb67c5960dafdb28cc20a799e28979f6353885381ddcbd4e844ce865e1f4690ada2242659b22e8039b5e69b3a581da65eee783a38690f5edf97b38f9f67a4d05622d4e018f93b166217796d0f190384d6fb30445d3b8ab91fee12c97f86ca3e2f6cdefcbc1c1552df3131a8793ad7aa104714201ab4743429ade062f06b89eed814116812fb4c66264dc74d288fc5d430edd8a40794a6c6f0afa9402c164efe93c8300fe8626d9d7c76de27e957b43f9b95f6f6854deecd743a59c523aca6531ff9744816b6a7b4dfc63ed8ee1a22dd0e369c1c820199dff499a02e2724c22ec092de8dfc8ca9654b8e0dcbf5f5c87ec1ec34395caa16e7088a88ff937635b78020c2603563668e7380784fcd5d1c8a509fa9d2684fc62edecad534cfd13c751a41d1c1e497dd55343d5d555d9d0ba21dcb1fc8614256ea6dc9b40b6a89952f81c68af3ced8dfe94f892eb58ffa8fe7155b2be14e2a4cc4f9d35ee70dfa985ca17d37eed2ab8264891c48c5258f110a666ba60264037ac192d31acd0fd2c0e2682ffb56beecb80c8ce10abda5f4c7411cc59ef541d51a24a2143566cd71057be371bec56e685825c6810ca8fd786d5df8d58dd23310230d8c2863891951f502e8f996a23cc456426efbf535e5475be5376b48a9888c55d04407412a20f23ec4a70341a5211166fb6cbfb1be2b4f2bfdaa48639d84b07bbca556868643d8f9b2fadde44d08a1aefa82fcb5139a86765d0a97c858d57b298925285b98aea155ad3de704f4cde918f8a0f87327fb32092c8797729004fc6d09fcebc9f65de51f822e5b4bb4cb9e9056d66561b99d59e57811a4378514c8516c50d67b72427940e417b43e42bb3e584ed0c19728e0caf4ebf761841acf005d54d6fd938f3c66a4808a47fa0de0fd13ef24fb7fd55db2379f288ca6ffc7315e719ba006b494d22c6e710112a039ec2f5f4701050d9142bd1e45ea9719fa03064d4aee77147b5ef8fda3705a266d77c3891a5a41695c6e281576b5050e9be128b14d602721e0c7786deecf35a28c29d9bb3e686194ea2853a652e28bd9c83eb6f6be56e24477a7df47ccafb9bcf2348638080ef995ff8e54a07b441440e747135cf27caeb2231efe913f5b5f9d852e3dd19ff46bad752349f91138087f2088df5e796dc86c32663fe7d43118ab47d8585aa58f42f1c6fbcc26d7c185b94f6a1ad7baa1b52bee4951badc9bb6a70ff85c9a3123e1c977c4f595659e919de2491f899463d57a67638a4fe580317cc6e9e21411850cbccfb42026adc1720dae879f2dc2921ab9021f65c0774c70a150638fd0d7290e58b086070ca3366c6edb0c018cc3aa54702150d618283df8c3e2ef18b23149c6ffa2123a2136cd7a51e93e5cc85e9f570a808821089bce3eeb6f3b82625948ba61dcc5df51865f2eba0d82c8f13a9b98ff99728e8afc8f44db04965abc3516ed2995d1708c49ccb0776f40bff7332a0574aaeae141fab2830a66250685a6f021309b9511c834915c98eecbb676bfba23d1748db207cbf8e30813b2486f4c0e2c6accdb14c9a85aa58f4a251cc20ff6f9d4e023147551ccf2cefd07dad55be5cb4127b06ff8b08bcd58fc8701f18ebc3ec9377b0d294fc4bf480813decc6aea77a7070fb4cb7143522dc3abb7ddcfc085083cf4a3350c3c70c2d1bb85c8e91152b830982c38fb22d72b73eb7d125c5ad84c8ef31dbc39980229fbc16cbc3c25a61325abb1aa25c3fe635e041e768e2502846447af08c7e4ddf9437660041d79ed1f9b2ee802d3ec9550dbef14c9c7f50355df0ac1d2c330dc560e81f0851b505fc9911ec94041842bc18fe6db9cfea886ba44d7f99d0faf1e90d2accd017c79e0c6046a5205fca35b0a2a9d6af90578f17be34b011e857e639b4b609687c73f53e07a8e94a5977c4802293381613dc3e9acdc1a94f947be0a1a53baa16b35dfc4d7a72605ea78ff7bc79819a142e995fa740aa2cce9f598bac3c8445dd266294c0f956f932a357871562d257d9995e5498423be84b00c6573c23dc96523ca095df191c5be403c24dada38b6737093a04ec2a59ded2bb58df195a10c83acb91cce6c1883aba83591f5f0c562e27bc281e5c2cbf854351801a52cdf05d563e7ba4590dee99e254667596c43ce7bf29f0fc5d44a7d3b551eac7fa9222f9315f12b781567ef0f792e467a86667d8d666a12ea15f14af2f09f7090d8a1972151026d76d5acf5232e9b9f336f0930083ab7cc00c091be8293b31e41124702b098e58a9e901a58921abb02a61cd75c3704cc4a9105c12ee9bc939e46929e0f23b7d6f3acd344134543c712bd49557a6fb75f7de7c1a5cbdb5a211394d1d392125288551e1e69ef8befc908775718076b0711665a4600765b5a9c503e670b39fc038067036ecf05d68dd19477012c0d8dfbe258ab950f6e09cae001749f65009c29e84c19458211767335c715cfdcd850f7cd2a748276936590b06b3a33850cf55fdc7aab9f6100be830ee591f354738f6874a6a7d8c0a1902d599edbde983538705b38661d9950e2405d14847adb89f68bd289903369b42b65630a44bec1f9785c9e734539e8d8d9fbe8d44460b22da28cda6c6803cb988770ee912db552dfca1a2c9816cf044afd474cfe6fae1f281030251abec3045182d528ee8bc7588d0d0ea28cfad2ddef78c9473ed4c562448a9dc5d003dfda86be8f982a6a536371553596de641ef7d7e82e4281dfd0ba093fb25ed1f268de1b90d2e0d4e12ba16c91697d916e9997f4a7a330cce94477f565d8edec0b385a33cf74c566ce9de83e14ed09aceda24f22fe8159b410aa2615a3efa8076638279419a2c218286296eff6fd7efd4621f8bd7fc31a76d1dfbb738bc4d0970eded743ee95bcf541c5c276ab23c21f36bd5146ff6722b4ba15989f970968f7af6fb1b8cfd71f7a38100472c8c03aef46c359f53672a7492c679e664bf8456612df9ab69e44e95185a374fca4c9d8dfd968cbe730773a8c3931f6e4062c20ac855e96871c2820aded8ac8f9db5532d88e2c241fd7c080516da6213e58097cdf4d8fc0ccd78fed7fa25f2fdbfc1c2cf7d88a2af9eb77b21972d4a9621de3bdfb716d93ee7d34ad82ecf4dd612e03446b0442fecffb75177a6957d5bc776ae53d55bbe413dd81532a06f5e435c4ca56c947289cdacf3e0ab0a2e5052a0450f3238148698f1d491a53b75b22a679e9b74ab30495fd3524c4026b25e995481b07ed32c2e86b8663cc5dcfb039bfc0fd7687c64f8b1b4888af818df4f66675fe6db46b53ec94b0480186ff1269727728430a86691a7be5edc55ee139046497c0894676d54148154e52aaabad7216888169763fc3cb4147c4d602e41154ab5d35779a075c24d307028b0bd44f14f952dbba2cd612a9a9792d0934d84d3c7b3ca70ba4b93302212c5eb7e2d8c2f055678e57bec2e7ff149795563905e5dc4906ac6b3a93f8f9256bb0305f6f77431cc0bce2a37552c6260dde370f36d3f9c40cf7fea2bbd8352657b20cae8f9cd4a1f7d16ce690e2025da479e9750e39e9de2cefc585c6ea0e3029649fcdc1d3a13402253b0da0899c0f81bb4cbf79e88c1770c9b648ca6db0fd607ee4d7925c575e5b072f58bf8376c2c1de7b7a75dd64ae7276b2ec7336a4f3f828bdeb607d2628bb0140bba70046a1a1b4815f2ad56943878680431fb52198304b184a1fc12f78ee696aeaa469d627d03b1b32f32474b0139fdd8a80bbde2d8d2512106d3fd549c6dd831ccf1006305e330434618fc1c0c567fca7675e8eb45cf6e7807234833554932d8859ee7bff68830bed25343b3935a41d72539b8b6ed68353077fbea3a9703f7d2030d300d765746fcb45f5ab38a57b8788d89d43b553a6cc3395434bb676af6b40bbfa88e3ea859f775cccf940d78b39bdb825c929a759ee46aa527406e8198f1eb49687","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c8468bfdae736e04c92ec57ec57c68df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
